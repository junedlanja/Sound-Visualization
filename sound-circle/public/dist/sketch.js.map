{"version":3,"file":"sketch.js","sources":["../node_modules/p5ex/lib/p5ex.mjs"],"sourcesContent":["/**\n* An extension of p5.js.\n* Including module: no-more-for-loops (Copyright 2018 FAL, licensed under MIT).\n* GitHub repository: {@link https://github.com/fal-works/p5ex}\n* @module p5ex\n* @copyright 2018 FAL\n* @author FAL <falworks.contact@gmail.com>\n* @license MIT\n* @version 0.5.3\n*/\n\n/**\n * Spatial region.\n */\nclass Region {\n}\n/**\n * Rectangle-shaped spatial region.\n */\nclass RectangleRegion extends Region {\n    get width() { return this.rightPositionX - this.leftPositionX; }\n    get height() { return this.bottomPositionY - this.topPositionY; }\n    get area() { return this.width * this.height; }\n    constructor(x1, y1, x2, y2, margin = 0) {\n        super();\n        this.leftPositionX = x1 - margin;\n        this.topPositionY = y1 - margin;\n        this.rightPositionX = x2 + margin;\n        this.bottomPositionY = y2 + margin;\n    }\n    contains(position, margin = 0) {\n        return (position.x >= this.leftPositionX - margin && position.x <= this.rightPositionX + margin &&\n            position.y >= this.topPositionY - margin && position.y <= this.bottomPositionY + margin);\n    }\n    constrain(position, margin = 0) {\n        if (position.x < this.leftPositionX - margin)\n            position.x = this.leftPositionX - margin;\n        else if (position.x > this.rightPositionX + margin)\n            position.x = this.rightPositionX + margin;\n        if (position.y < this.topPositionY - margin)\n            position.y = this.topPositionY - margin;\n        else if (position.y > this.bottomPositionY + margin)\n            position.y = this.bottomPositionY + margin;\n    }\n}\n// default region -> add\n\n/**\n * (To be filled)\n * @hideConstructor\n */\nclass ScalableCanvas {\n    constructor(p5Instance, parameter, node, rendererType) {\n        this.p = p5Instance;\n        this.canvasElement = p5Instance.createCanvas(parameter.scaledWidth, parameter.scaledHeight, rendererType);\n        if (this.canvasElement && 'parent' in this.canvasElement) {\n            this.canvasElement.parent(node);\n        }\n        this.region = new RectangleRegion(0, 0, 0, 0);\n        this.nonScaledShortSideLength = parameter.nonScaledShortSideLength;\n        this.updateSize();\n    }\n\n    /**\n     * (To be filled)\n     */\n    get scaleFactor() {\n        return this._scaleFactor;\n    }\n    /**\n     * (To be filled)\n     */\n    get nonScaledWidth() {\n        return this._nonScaledWidth;\n    }\n    /**\n     * (To be filled)\n     */\n    get nonScaledHeight() {\n        return this._nonScaledHeight;\n    }\n    /**\n     * (To be filled)\n     */\n    get aspectRatio() {\n        return this._aspectRatio;\n    }\n    /**\n     * (To be filled)\n     * @param parameter\n     */\n    resize(parameter) {\n        this.p.resizeCanvas(parameter.scaledWidth, parameter.scaledHeight);\n        this.nonScaledShortSideLength = parameter.nonScaledShortSideLength;\n        this.updateSize();\n    }\n    /**\n     * (To be filled)\n     */\n    updateSize() {\n        const p = this.p;\n        this._scaleFactor = Math.min(p.width, p.height) / this.nonScaledShortSideLength;\n        this._inversedScaleFactor = 1 / this._scaleFactor;\n        this._nonScaledWidth = p.width / this._scaleFactor;\n        this._nonScaledHeight = p.height / this._scaleFactor;\n        this._aspectRatio = p.width / p.height;\n        this.region.rightPositionX = this._nonScaledWidth;\n        this.region.bottomPositionY = this._nonScaledHeight;\n    }\n    /**\n     * Runs scale() of the current p5 instance for fitting the sketch to the current canvas.\n     * Should be called every frame before drawing objects on the canvas.\n     */\n    scale() {\n        this.p.scale(this._scaleFactor);\n    }\n    /**\n     * Runs scale() with the inversed scale factor.\n     */\n    cancelScale() {\n        this.p.scale(this._inversedScaleFactor);\n    }\n    /**\n     * Converts a length value on the scaled canvas to the non-scaled one.\n     * Typically used for interpreting mouseX and mouseY.\n     * @param {number} scaledLength - scaled length value\n     */\n    getNonScaledValueOf(scaledLength) {\n        return scaledLength / this._scaleFactor;\n    }\n}\nScalableCanvas.DUMMY_PARAMETERS = {\n    scaledWidth: 100,\n    scaledHeight: 100,\n    nonScaledShortSideLength: 100,\n};\n\n/**\n * (To be filled)\n * (This is not implemented as an enum because it is not supported by rollup)\n */\nconst ScalableCanvasTypes = {\n    SQUARE640x640: 'SQUARE640x640',\n    RECT640x480: 'RECT640x480',\n    FULL: 'FULL',\n    CUSTOM: 'CUSTOM',\n};\n\nclass NormalColorUnit {\n    constructor(p, p5Color) {\n        this.p = p;\n        this.p5Color = p5Color;\n    }\n    stroke() {\n        this.p.currentRenderer.stroke(this.p5Color);\n    }\n    fill() {\n        this.p.currentRenderer.fill(this.p5Color);\n    }\n}\nclass NoColorUnit {\n    constructor(p) {\n        this.p = p;\n    }\n    stroke() {\n        this.p.currentRenderer.noStroke();\n    }\n    fill() {\n        this.p.currentRenderer.noFill();\n    }\n}\nclass UndefinedColorUnit {\n    stroke() {\n    }\n    fill() {\n    }\n}\nclass AlphaColorUnit {\n    constructor(p, c, alphaResolution = 256) {\n        this.p = p;\n        const array = [];\n        for (let alphaFactor = 0; alphaFactor < alphaResolution; alphaFactor += 1) {\n            array.push(p.color(p.red(c), p.green(c), p.blue(c), p.alpha(c) * alphaFactor / (alphaResolution - 1)));\n        }\n        this.colorArray = array;\n        this.maxIndex = alphaResolution - 1;\n    }\n    stroke(alphaValue) {\n        this.p.currentRenderer.stroke(this.getColor(alphaValue));\n    }\n    fill(alphaValue) {\n        this.p.currentRenderer.fill(this.getColor(alphaValue));\n    }\n    getColor(alphaValue) {\n        return this.colorArray[alphaValue ? Math.floor(this.p.map(alphaValue, 0, 255, 0, this.maxIndex)) : this.maxIndex];\n    }\n}\nfunction colorUnit(p, p5Color, alphaEnabled, alphaResolution) {\n    if (!p || p5Color === undefined)\n        return new UndefinedColorUnit();\n    if (p5Color === null)\n        return new NoColorUnit(p);\n    if (alphaEnabled)\n        return new AlphaColorUnit(p, p5Color, alphaResolution);\n    return new NormalColorUnit(p, p5Color);\n}\n/**\n * Composition of two p5.Color instances. One for stroke(), one for fill().\n */\nclass ShapeColor {\n    /**\n     *\n     * @param p - p5ex instance.\n     * @param {p5.Color | null | undefined} strokeColor - Color for stroke(). Null means noStroke().\n     * @param {p5.Color | null | undefined} fillColor - Color for fill(). Null means noFill().\n     * @param {boolean} [alphaEnabled]\n     * @param {number} [alphaResolution]\n     */\n    constructor(p, strokeColor, fillColor, alphaEnabled, alphaResolution) {\n        this.strokeColor = colorUnit(p, strokeColor, alphaEnabled, alphaResolution);\n        this.fillColor = colorUnit(p, fillColor, alphaEnabled, alphaResolution);\n    }\n    /**\n     * Applies colors to the current p5 renderer.\n     * @param {number} alphaValue - Alpha channel value (0 - 255)\n     */\n    applyColor(alphaValue) {\n        this.strokeColor.stroke(alphaValue);\n        this.fillColor.fill(alphaValue);\n    }\n}\n/**\n * Undefined object of p5ex.ShapeColor.\n * @static\n */\nShapeColor.UNDEFINED = new ShapeColor(undefined, undefined, undefined);\n\n/**\n * An empty function.\n */\nconst EMPTY_FUNCTION = () => { };\n/**\n * 1.5 * PI\n */\nconst ONE_AND_HALF_PI = 1.5 * Math.PI;\n\nconst dummyP5 = new p5((p) => {\n    p.setup = () => {\n        p.noCanvas();\n    };\n});\n\n/**\n * Calculates the squared value of the Euclidean distance between\n * two points (considering a point as a vector object).\n */\nfunction distSq(v1, v2) {\n    return Math.pow(v2.x - v1.x, 2) + Math.pow(v2.y - v1.y, 2) + Math.pow(v2.z - v1.z, 2);\n}\n/**\n * Multiplies the given matrix and array.\n * The number of matrix columns and the array length must be identical.\n * @param {number[][]} matrix - Any matrix.\n * @param {number[]} array - Any one-dimensional array of numbers.\n * @param {number[]} [target] - Target array for receiving the result.\n * @returns Product of the given values as an array.\n */\nfunction multiplyMatrixAndArray(matrix, array, target) {\n    const matrixRowCount = matrix.length;\n    const matrixColumnCount = matrix[0].length;\n\n    const resultArray = target || new Array(matrixRowCount);\n\n    for (let row = 0; row < matrixRowCount; row += 1) {\n        resultArray[row] = 0;\n        for (let col = 0; col < matrixColumnCount; col += 1) {\n            resultArray[row] += matrix[row][col] * array[col];\n        }\n    }\n    return resultArray;\n}\nconst TWO_PI = 2 * Math.PI;\n/**\n * Calculates the difference between two angles in range of -PI to PI.\n * @param angleA - the angle to subtract from\n * @param angleB - the angle to subtract\n */\nfunction angleDifference(angleA, angleB) {\n    let diff = (angleA - angleB) % TWO_PI;\n    if (diff < -Math.PI)\n        diff += TWO_PI;\n    else if (diff > Math.PI)\n        diff -= TWO_PI;\n    return diff;\n}\n/**\n * Calculates the direction angle from one vector to another.\n * @param referencePosition\n * @param targetPosition\n */\nfunction getDirectionAngle(referencePosition, targetPosition) {\n    return Math.atan2(targetPosition.y - referencePosition.y, targetPosition.x - referencePosition.x);\n}\n// Temporal vectors for calculation use in getClosestPositionOnLineSegment()\nconst tmpVectorAP = dummyP5.createVector();\nconst tmpVectorAB = dummyP5.createVector();\n/**\n * Returns the position on the line segment AB which is closest to the reference point P.\n * @param {p5.Vector} P - The position of the reference point.\n * @param {p5.Vector} A - The position of the line segment start point.\n * @param {p5.Vector} B - The position of the line segment end point.\n * @param {p5.Vector} target - The vector to receive the result.\n */\n\n/**\n * Just lerp.\n * @param startValue - The start value.\n * @param endValue - The end value.\n * @param ratio - The ratio between 0 and 1.\n */\nfunction lerp(startValue, endValue, ratio) {\n    return startValue + ratio * (endValue - startValue);\n}\n\n/**\n * Returns random value from the min number up to (but not including) the max number.\n */\nfunction randomBetween(min, max) {\n    return min + Math.random() * (max - min);\n}\n/**\n * Returns random integer from 0 up to (but not including) the max number.\n */\nfunction randomInt(maxInt) {\n    return Math.floor(Math.random() * maxInt);\n}\n/**\n * Returns random integer from the min number up to (but not including) the max number.\n */\nfunction randomIntBetween(minInt, maxInt) {\n    return minInt + randomInt(maxInt - minInt);\n}\n/**\n * Returns one of array elements randomly.\n * @param array\n */\nfunction getRandom(array) {\n    return array[randomInt(array.length)];\n}\n/**\n * Returns n or -n randomly. (n = provided number)\n * @param {number} n - any number\n */\nfunction randomSign(n) {\n    if (Math.random() < 0.5)\n        return n;\n    return -n;\n}\n/**\n * Returns and removes one array element randomly.\n * @param array\n */\nfunction popRandom(array) {\n    return array.splice(randomInt(array.length), 1)[0];\n}\n\n/**\n * Container class of number.\n */\nclass NumberContainer {\n    /**\n     * @constructor\n     * @param {number} value\n     */\n    constructor(value = 0) {\n        this.value = value;\n    }\n    valueOf() {\n        return this.value;\n    }\n}\n/**\n * Null object of NumberContainer.\n * @static\n */\nNumberContainer.NULL = new NumberContainer();\n\n/**\n * (To be filled)\n */\nclass WeightedRandomSelector {\n    constructor() {\n        this.candidateList = [];\n        this.candidateCount = 0;\n        this.totalProbabiligyWeight = 0;\n    }\n    /**\n     * Adds one element with provided weight of probability.\n     * @param element\n     * @param probabilityWeight\n     * @chainable\n     */\n    push(element, probabilityWeight) {\n        this.candidateList.push({\n            element,\n            threshold: this.totalProbabiligyWeight + probabilityWeight,\n        });\n        this.candidateCount += 1;\n        this.totalProbabiligyWeight += probabilityWeight;\n        return this;\n    }\n    /**\n     * Clears all elements.\n     * @chainable\n     */\n    clear() {\n        this.candidateList.length = 0;\n        this.candidateCount = 0;\n        this.totalProbabiligyWeight = 0;\n        return this;\n    }\n    /**\n     * Returns one element randomly.\n     * The probability for each element is:\n     * (probability weight of the element) / (total probability weight)\n     */\n    get() {\n        const rnd = Math.random() * this.totalProbabiligyWeight;\n        for (let i = 0; i < this.candidateCount; i += 1) {\n            if (rnd < this.candidateList[i].threshold)\n                return this.candidateList[i].element;\n        }\n        return this.candidateList[this.candidateCount - 1].element; // unreachable\n    }\n}\n\n/**\n * Linear easing function.\n * @param ratio\n */\nfunction easeLinear(ratio) {\n    return ratio;\n}\n/**\n * easeOutQuad.\n * @param ratio\n */\nfunction easeOutQuad(ratio) {\n    return -Math.pow(ratio - 1, 2) + 1;\n}\n/**\n * easeOutCubic.\n * @param ratio\n */\nfunction easeOutCubic(ratio) {\n    return Math.pow(ratio - 1, 3) + 1;\n}\n/**\n * easeOutQuart.\n * @param ratio\n */\nfunction easeOutQuart(ratio) {\n    return -Math.pow(ratio - 1, 4) + 1;\n}\nconst EASE_OUT_BACK_DEFAULT_COEFFICIENT = 1.70158;\n/**\n * easeOutBack.\n * @param ratio\n */\nfunction easeOutBack(ratio) {\n    const r = ratio - 1;\n    return ((EASE_OUT_BACK_DEFAULT_COEFFICIENT + 1) * Math.pow(r, 3)\n        + EASE_OUT_BACK_DEFAULT_COEFFICIENT * Math.pow(r, 2) + 1);\n}\n/**\n * Returns an easeOut function.\n * @param exponent - Integer from 1 to 4.\n */\nfunction getEasingFunction(exponent) {\n    switch (Math.floor(exponent)) {\n        default:\n        case 1:\n            return easeLinear;\n        case 2:\n            return easeOutQuad;\n        case 3:\n            return easeOutCubic;\n        case 4:\n            return easeOutQuart;\n    }\n}\n\n/**\n * (To be filled)\n */\nclass RandomShapeColor {\n    constructor() {\n        this.candidateArray = [];\n    }\n    /**\n     * (To be filled)\n     * @param createShapeColor - Any function which returns a p5ex.ShapeColor instance.\n     * @param {number} candidateCount - Number of color candidates to push.\n     */\n    pushCandidateFromFunction(createShapeColor, candidateCount) {\n        for (let i = 0; i < candidateCount; i += 1) {\n            this.candidateArray.push(createShapeColor());\n        }\n        return this;\n    }\n    /**\n     * (To be filled)\n     * @param {p5.Color} shapeColor - Any p5.Color instance.\n     * @param {number} candidateCount - Number of color candidates to push.\n     */\n    pushCandidate(shapeColor, candidateCount = 1) {\n        for (let i = 0; i < candidateCount; i += 1) {\n            this.candidateArray.push(shapeColor);\n        }\n        return this;\n    }\n    /**\n     * Clears all color candidates.\n     */\n    clear() {\n        this.candidateArray.length = 0;\n        return this;\n    }\n    /**\n     * Returns one of color candidates randomly.\n     */\n    get() {\n        return getRandom(this.candidateArray);\n    }\n}\n\nfunction createCielabToXyzFunc() {\n    const delta = 6 / 29;\n    const constantA = 16 / 116;\n    const constantB = 3 * delta * delta;\n    return (value) => {\n        if (value > delta)\n            return value * value * value;\n        return (value - constantA) * constantB;\n    };\n}\nconst cielabToXyzFunc = createCielabToXyzFunc();\n/**\n * Converts color values from CIELAB (D65) to XYZ.\n * @param {number[]} cielabValue - Value array of L*, a*, b* (D65).\n * @param {Illuminant} illuminant - Instance of Illuminant.\n * @param {number[]} [target] - Target array for receiving the result.\n * @returns {number[]} XYZ value array.\n */\nfunction cielabValueToXyzValue(cielabValue, illuminant, target) {\n    const yFactor = (cielabValue[0] + 16.0) / 116.0;\n    const xFactor = yFactor + cielabValue[1] / 500.0;\n    const zFactor = yFactor - cielabValue[2] / 200.0;\n    if (target) {\n        target[0] = illuminant.tristimulusValues[0] * cielabToXyzFunc(xFactor);\n        target[1] = illuminant.tristimulusValues[1] * cielabToXyzFunc(yFactor);\n        target[2] = illuminant.tristimulusValues[2] * cielabToXyzFunc(zFactor);\n        return target;\n    }\n    return [\n        illuminant.tristimulusValues[0] * cielabToXyzFunc(xFactor),\n        illuminant.tristimulusValues[1] * cielabToXyzFunc(yFactor),\n        illuminant.tristimulusValues[2] * cielabToXyzFunc(zFactor),\n    ];\n}\n\n/**\n * Matrix for conversion color values from XYZ to linear RGB.\n * Values from \"7. Conversion from XYZ (D65) to linear sRGB values\" in\n * http://www.color.org/chardata/rgb/sRGB.pdf (April 2015)\n * @constant {number[][]} xyzToLinearRgbConversionMatrix\n * @ignore\n */\nconst xyzToLinearRgbConversionMatrix = [\n    [3.2406255, -1.537208, -0.4986286],\n    [-0.9689307, 1.8757561, 0.0415175],\n    [0.0557101, -0.2040211, 1.0569959],\n];\n/**\n * Matrix for converting color values from linear RGB to XYZ.\n * This is an inversed matrix of xyzToLinearRgbConversionMatrix\n * which is pre-calculated by math.js.\n * @constant {number[][]} linearRgbToXyzConversionMatrix\n * @ignore\n */\n\n/**\n * CIE standard illuminant.\n */\nclass Illuminant {\n    constructor(name, tristimulusValues) {\n        this.name = name;\n        this.tristimulusValues = tristimulusValues;\n    }\n}\n\n/**\n * Map of illuminants.\n */\nconst Illuminants = {\n    D50: new Illuminant('D50', [0.9642, 1.0000, 0.8251]),\n    D55: new Illuminant('D55', [0.9568, 1.0000, 0.9214]),\n    D65: new Illuminant('D65', [0.95047, 1.00000, 1.08883]),\n    E: new Illuminant('E', [1, 1, 1]),\n};\n\n/**\n * Applies display gamma correction to the given number.\n * @param value - any number in a linear color space (0 - 1).\n * @ignore\n */\nfunction degamma(value) {\n    if (value <= 0.0031308)\n        return 12.92 * value;\n    return 1.055 * Math.pow(value, 1.0 / 2.4) - 0.055;\n}\n/**\n * Returns the difference of two colors. The alpha values of the original colors will be ignored.\n * @param {p5.Color} c1 - The color to subtract from\n * @param {p5.Color} c2 - The color to subtract\n * @param {number} [alphaValue] - Alpha value of the result color\n */\nfunction subtractColor(c1, c2, alphaValue) {\n    return dummyP5.color(dummyP5.red(c1) - dummyP5.red(c2), dummyP5.green(c1) - dummyP5.green(c2), dummyP5.blue(c1) - dummyP5.blue(c2), alphaValue);\n}\n/**\n * Creates a new p5.Color instance in HSB color mode and\n * immediately reset the color mode to default.\n * @param {number} h - Hue (0 - 360)\n * @param {number} s - Saturation (0 - 100)\n * @param {number} b - Brightness (0 - 100)\n * @param {number} [a] - Alpha (0 - 255)\n */\nfunction hsbColor(h, s, b, a) {\n    dummyP5.colorMode(dummyP5.HSB, 360, 100, 100, 255);\n    const c = dummyP5.color(h, s, b);\n    dummyP5.colorMode(dummyP5.RGB, 1, 1, 1, 255);\n    const gammaCorrectedColor = dummyP5.color(degamma(dummyP5.red(c)), degamma(dummyP5.green(c)), degamma(dummyP5.blue(c)), a);\n    dummyP5.colorMode(dummyP5.RGB, 255, 255, 255, 255);\n    return gammaCorrectedColor;\n}\n\nlet currentIlluminant = Illuminants.D50;\n/**\n * Sets the current illuminant. (e.g. D50, D65 etc.)\n * @param illuminant - Any Illuminant.\n * @example setIlluminant(Illuminants.D65);\n */\nfunction setIlluminant(illuminant) {\n    currentIlluminant = illuminant;\n}\nconst temporalArray1 = [0, 0, 0];\nconst temporalArray2 = [0, 0, 0];\nconst temporalArray3 = [0, 0, 0];\nconst temporalArray4 = [0, 0, 0];\nfunction assignArray(array, v0, v1, v2) {\n    array[0] = v0;\n    array[1] = v1;\n    array[2] = v2;\n    return array;\n}\n/**\n * Clips the given linear RGB factor to the valid range (0 - 1)\n * and converts it to an sRGB value (0 - 255).\n * @param factor - Factor of either red, green or blue in the linear RGB color space.\n * @returns sRGB value.\n * @ignore\n */\nfunction linearRgbFactorToSrgbValue(factor) {\n    return degamma(Math.min(Math.max(factor, 0), 1)) * 255;\n}\n/**\n * Converts CIELAB values to an array of RGB values (0 - 255).\n * @param {number} lValue - L*: Lightness (0 - 100)\n * @param {number} aValue - a* (0 - ca. 100)\n * @param {number} bValue - b* (0 - ca. 100)\n * @param {number} [alphaValue] - Alhpa value (0 - 255)\n * @returns New Array of sRGB values.\n */\nfunction cielabColor(lValue, aValue, bValue, alphaValue) {\n    const labValue = assignArray(temporalArray1, lValue, aValue, bValue);\n    const xyzValue = cielabValueToXyzValue(labValue, currentIlluminant, temporalArray2);\n    const rgbFactor = multiplyMatrixAndArray(xyzToLinearRgbConversionMatrix, xyzValue, temporalArray3);\n    const srgbValue = assignArray(temporalArray4, linearRgbFactorToSrgbValue(rgbFactor[0]), linearRgbFactorToSrgbValue(rgbFactor[1]), linearRgbFactorToSrgbValue(rgbFactor[2]));\n    return alphaValue ? [\n        srgbValue[0],\n        srgbValue[1],\n        srgbValue[2],\n        alphaValue,\n    ] : [\n        srgbValue[0],\n        srgbValue[1],\n        srgbValue[2],\n    ];\n}\n/**\n * Converts CIELCh values to an array of RGB values (0 - 255).\n * @param {number} lValue - L*: Lightness (0 - 100)\n * @param {number} cValue - C*: Chroma (0 - ca. 100)\n * @param {number} hValue - h*: Hue (0 - 2PI)\n * @param {number} [alphaValue] - Alhpa value (0 - 255)\n */\nfunction cielchColor(lValue, cValue, hValue, alphaValue) {\n    return cielabColor(lValue, cValue * Math.cos(hValue), cValue * Math.sin(hValue), alphaValue);\n}\n\n/**\n * (To be filled)\n */\nclass ScreenEffect {\n    constructor(p) {\n        this.p = p;\n    }\n}\n/**\n * (To be filled)\n */\nclass ScreenShake extends ScreenEffect {\n    constructor(p, dampingRatio = 0.95) {\n        super(p);\n        this.dampingRatio = dampingRatio;\n        this.amplitude = 0;\n        this.offsetX = 0;\n        this.offsetY = 0;\n    }\n    apply() {\n        if (this.amplitude === 0)\n            return;\n        this.offsetX = Math.random() * this.amplitude;\n        this.offsetY = Math.random() * this.amplitude;\n        this.p.currentRenderer.translate(this.offsetX, this.offsetY);\n        this.amplitude = this.amplitude * this.dampingRatio;\n        if (this.amplitude < 1)\n            this.amplitude = 0;\n    }\n    set(amplitude) {\n        this.amplitude = Math.max(this.amplitude, amplitude);\n    }\n    reset() {\n        this.amplitude = 0;\n    }\n    cancel() {\n        this.p.currentRenderer.translate(-this.offsetX, -this.offsetY);\n    }\n}\n/**\n * (To be filled)\n */\nclass ScreenFlash extends ScreenEffect {\n    constructor(p, flashColor = p.color(255)) {\n        super(p);\n        this.alphaValue = 0;\n        this.valueChange = 0;\n        this.flashColor = new ShapeColor(p, null, flashColor, true);\n    }\n    apply() {\n        if (this.alphaValue === 0)\n            return;\n        this.flashColor.applyColor(this.alphaValue);\n        this.p.currentRenderer.rect(0, 0, this.p.scalableCanvas.nonScaledWidth, this.p.scalableCanvas.nonScaledHeight);\n        this.alphaValue -= this.valueChange;\n        if (this.alphaValue < 1)\n            this.alphaValue = 0;\n    }\n    set(initialAlphaValue, durationSeconds) {\n        this.alphaValue = initialAlphaValue;\n        this.valueChange = initialAlphaValue / (durationSeconds * this.p.idealFrameRate);\n    }\n    reset() {\n        this.alphaValue = 0;\n    }\n}\n\n/**\n * (To be filled)\n */\nclass AlphaBackground {\n    /**\n     *\n     * @param p5exInstance\n     * @param backgroundColor\n     * @param drawIntervalFrameCount\n     * @param blendModeString\n     * @param defaultBlendModeString\n     */\n    constructor(p5exInstance, backgroundColor, drawIntervalFrameCount = 1, blendModeString, defaultBlendModeString) {\n        this.p = p5exInstance;\n        this.backgroundColor = backgroundColor;\n        this.drawIntervalFrameCount = drawIntervalFrameCount;\n        this.blendModeString = blendModeString;\n        this.defaultBlendModeString = defaultBlendModeString;\n    }\n    /**\n     * Draws the background.\n     */\n    draw() {\n        if (this.p.frameCount % this.drawIntervalFrameCount !== 0)\n            return;\n        if (this.blendModeString)\n            this.p.blendMode(this.blendModeString);\n        this.p.noStroke();\n        this.p.fill(this.backgroundColor);\n        this.p.rect(0, 0, this.p.width, this.p.height);\n        if (this.defaultBlendModeString)\n            this.p.blendMode(this.defaultBlendModeString);\n    }\n}\n\n/**\n * Returns true if the mouse is within the canvas.\n * @param p - The p5 instance.\n */\nfunction mouseIsInCanvas(p) {\n    if (p.mouseX < 0)\n        return false;\n    if (p.mouseX > p.width)\n        return false;\n    if (p.mouseY < 0)\n        return false;\n    if (p.mouseY > p.height)\n        return false;\n    return true;\n}\n\nfunction loopArrayLimited(array, callback, arrayLength) {\n    let i = 0;\n    while (i < arrayLength) {\n        callback(array[i], i, array);\n        i += 1;\n    }\n}\n/**\n * Executes a provided function once for each array element.\n * @param {Array} array\n * @param {loopArrayCallBack} callback\n */\nfunction loopArray(array, callback) {\n    loopArrayLimited(array, callback, array.length);\n}\nfunction loopArrayBackwardsLimited(array, callback, arrayLength) {\n\n    while (arrayLength--) {\n        callback(array[arrayLength], arrayLength, array);\n    }\n}\n/**\n * Executes a provided function once for each array element in descending order.\n * @param {Array} array\n * @param {loopArrayCallback} callback\n */\nfunction loopArrayBackwards(array, callback) {\n    loopArrayBackwardsLimited(array, callback, array.length);\n}\n/**\n * @callback loopArrayCallBack\n * @param {} currentValue\n * @param {number} [index]\n * @param {Array} [array]\n */\n\nfunction roundRobinLimited(array, callback, arrayLength) {\n    for (let i = 0, len = arrayLength - 1; i < len; i += 1) {\n        for (let k = i + 1; k < arrayLength; k += 1) {\n            callback(array[i], array[k]);\n        }\n    }\n}\n/**\n * Executes a provided function once for each pair within the array.\n * @param {Array} array\n * @param {roundRobinCallBack} callback\n */\nfunction roundRobin(array, callback) {\n    roundRobinLimited(array, callback, array.length);\n}\n/**\n * @callback roundRobinCallBack\n * @param {} element\n * @param {} otherElement\n */\n\nfunction nestedLoopJoinLimited(array, otherArray, callback, arrayLength, otherArrayLength) {\n    for (let i = 0; i < arrayLength; i += 1) {\n        for (let k = 0; k < otherArrayLength; k += 1) {\n            callback(array[i], otherArray[k]);\n        }\n    }\n}\n/**\n * Joins two arrays and executes a provided function once for each joined pair.\n * @param {Array} array\n * @param {Array} otherArray\n * @param {nestedLoopJoinCallBack} callback\n */\nfunction nestedLoopJoin(array, otherArray, callback) {\n    nestedLoopJoinLimited(array, otherArray, callback, array.length, otherArray.length);\n}\n/**\n * @callback nestedLoopJoinCallBack\n * @param {} element\n * @param {} otherElement\n */\n\n/**\n * A class containing an array and several loop methods.\n */\nclass LoopableArray {\n    /**\n     * @param {number} initialCapacity\n     */\n    constructor(initialCapacity = 256) {\n\n        this.array = new Array(initialCapacity);\n        this.length = 0;\n    }\n    /**\n     * Returns a specific element.\n     * It is recommended to check that you are going to specify a valid index number\n     * before calling this method.\n     * @returns The specified element.\n     */\n    get(index) {\n        return this.array[index];\n    }\n    /**\n     * Returns the last element.\n     * It is recommended to check that this array is not empty before calling this method.\n     * @returns The last element.\n     */\n    getLast() {\n        return this.array[this.length - 1];\n    }\n    /**\n     * Adds one element to the end of the array and returns the new length of the array.\n     * @param {} element - The element to add to the end of the array.\n     */\n    push(element) {\n        this.array[this.length] = element;\n        this.length += 1;\n        return this.length;\n    }\n    /**\n     * Adds elements to the end of the array and returns the new length of the array.\n     * @param {Array} array - The elements to add to the end of the array.\n     */\n    pushRawArray(array, arrayLength = array.length) {\n        for (let i = 0; i < arrayLength; i += 1) {\n            this.array[this.length + i] = array[i];\n        }\n        this.length += arrayLength;\n        return this.length;\n    }\n    /**\n     * Adds all elements from another LoopableArray and returns the new length of the array.\n     * @param {LoopableArray} otherLoopableArray\n     */\n    pushAll(otherLoopableArray) {\n        return this.pushRawArray(otherLoopableArray.array, otherLoopableArray.length);\n    }\n    /**\n     * Removes and returns the last element.\n     * It is recommended to check that this array is not empty before calling this method.\n     * @returns The last element.\n     */\n    pop() {\n        this.length -= 1;\n        return this.array[this.length];\n    }\n    /**\n     * Clears the array.\n     */\n    clear() {\n        this.length = 0;\n    }\n    /**\n     * @callback loopArrayCallBack\n     * @param {} currentValue\n     * @param {number} [index]\n     * @param {Array} [array]\n     */\n    /**\n     * Executes a provided function once for each array element.\n     * @param {loopArrayCallBack} callback\n     */\n    loop(callback) {\n        loopArrayLimited(this.array, callback, this.length);\n    }\n    /**\n     * Executes a provided function once for each array element in descending order.\n     * @param {loopArrayCallBack} callback\n     */\n    loopBackwards(callback) {\n        loopArrayBackwardsLimited(this.array, callback, this.length);\n    }\n    /**\n     * @callback elementPairCallBack\n     * @param {} element\n     * @param {} otherElement\n     */\n    /**\n     * Executes a provided function once for each pair within the array.\n     * @param {elementPairCallback} callback\n     */\n    roundRobin(callback) {\n        roundRobinLimited(this.array, callback, this.length);\n    }\n    /**\n     * Joins two arrays and executes a provided function once for each joined pair.\n     * @param {LoopableArray} otherArray\n     * @param {elementPairCallback} callback\n     */\n    nestedLoopJoin(otherArray, callback) {\n        nestedLoopJoinLimited(this.array, otherArray.array, callback, this.length, otherArray.length);\n    }\n}\n\n/**\n * (To be filled)\n */\nclass TwoDimensionalArray extends LoopableArray {\n    /**\n     * (To be filled)\n     * @param {number} xCount\n     * @param {number} yCount\n     * @param fillElement\n     */\n    constructor(xCount, yCount, fillElement) {\n        super(xCount * yCount);\n        this.xCount = xCount;\n        this.yCount = yCount;\n        if (fillElement) {\n            for (let i = 0, len = xCount * yCount; i < len; i += 1) {\n                this.push(fillElement);\n            }\n        }\n    }\n    /**\n     * Returns the specified element.\n     * @param x\n     * @param y\n     */\n    get2D(x, y) {\n        return this.array[x + this.xCount * y];\n    }\n    /**\n     * (To be filled)\n     * @param x\n     * @param y\n     * @param element\n     */\n    set2D(x, y, element) {\n        this.array[x + this.xCount * y] = element;\n    }\n}\n\n/**\n * A Naive implementation of an edge between two objects.\n */\nclass NaiveEdge {\n    /**\n     *\n     * @param nodeA\n     * @param nodeB\n     */\n    constructor(nodeA, nodeB) {\n        this.nodeA = nodeA;\n        this.nodeB = nodeB;\n    }\n    /**\n     * Returns true if the provided node is incident to this edge.\n     * @param node\n     */\n    isIncidentTo(node) {\n        return node === this.nodeA || node === this.nodeB;\n    }\n    /**\n     * Returns the adjacent node of the given node via this edge.\n     * If this edge is not incident to the given node, returns always the end point node.\n     * @param {T} node - any node which is incident to this edge\n     */\n    getAdjacentNode(node) {\n        if (node === this.nodeB)\n            return this.nodeA;\n        return this.nodeB;\n    }\n}\n\n/**\n * (To be filled)\n */\nclass NullCell {\n    getNeighborCell(relativeX, relativeY) {\n        return this;\n    }\n    setNeighborCell(relativeX, relativeY, cell) { }\n}\nconst NULL = new NullCell();\n/**\n * (To be filled)\n */\nclass NaiveCell {\n    /**\n     *\n     * @param neighborRange\n     */\n    constructor(neighborRange = 1) {\n        this.neighborCells = new TwoDimensionalArray(2 * neighborRange + 1, 2 * neighborRange + 1, NULL);\n    }\n    /**\n     * Returns the specified neighbor cell.\n     * @param {number} relativeX\n     * @param {number} relativeY\n     */\n    getNeighborCell(relativeX, relativeY) {\n        const neighborRange = Math.floor(this.neighborCells.xCount / 2);\n        if (relativeX < -neighborRange || relativeX > neighborRange ||\n            relativeY < -neighborRange || relativeY > neighborRange)\n            return NULL;\n        return this.neighborCells.get2D(relativeX + neighborRange, relativeY + neighborRange);\n    }\n    /**\n     * Sets the provided cell as a neighbor of this cell.\n     * @param relativeX\n     * @param relativeY\n     * @param cell\n     */\n    setNeighborCell(relativeX, relativeY, cell) {\n        const neighborRange = Math.floor(this.neighborCells.xCount / 2);\n        this.neighborCells.set2D(relativeX + neighborRange, relativeY + neighborRange, cell);\n    }\n}\n/**\n * (To be filled)\n */\nclass Grid {\n    /**\n     *\n     * @param {number} xCount\n     * @param {number} yCount\n     * @param {number} neighborRange\n     * @param {boolean} loopAtEndOfScreen\n     */\n    constructor(xCount, yCount, neighborRange, loopAtEndOfScreen, cellFactory, nullCell) {\n        this.nullCell = nullCell;\n        this.cell2DArray = new TwoDimensionalArray(xCount, yCount, nullCell);\n        this.cellIndexMap = new Map();\n        for (let yIndex = 0; yIndex < yCount; yIndex += 1) {\n            for (let xIndex = 0; xIndex < xCount; xIndex += 1) {\n                const cell = cellFactory(neighborRange);\n                this.cell2DArray.set2D(xIndex, yIndex, cell);\n                this.cellIndexMap.set(cell, { x: xIndex, y: yIndex });\n            }\n        }\n        this.cell2DArray.loop((cell) => {\n            this.setNeighborCells(cell, neighborRange, loopAtEndOfScreen);\n        });\n    }\n    /**\n     * Returns the specified cell.\n     * @param {number} x - X index.\n     * @param {number} y - Y index.\n     */\n    getCell(x, y) {\n        return this.cell2DArray.get2D(x, y);\n    }\n    /**\n     * Returns the x and y index of the given cell.\n     * @param cell\n     */\n    getCellIndex(cell) {\n        return this.cellIndexMap.get(cell) || { x: -1, y: -1 };\n    }\n    /**\n     * (To be filled)\n     * @param referenceCell\n     * @param {number} relX\n     * @param {number} relY\n     * @param {boolean} loopAtEndOfScreen\n     */\n    getRelativePositionCell(referenceCell, relX, relY, loopAtEndOfScreen) {\n        if (referenceCell === this.nullCell)\n            return referenceCell;\n        if (relX === 0 && relY === 0)\n            return referenceCell;\n        const referenceIndex = this.getCellIndex(referenceCell);\n        const targetIndex = {\n            x: referenceIndex.x + relX,\n            y: referenceIndex.y + relY,\n        };\n        if (loopAtEndOfScreen) {\n            if (targetIndex.x < 0)\n                targetIndex.x += this.cell2DArray.xCount;\n            else if (targetIndex.x >= this.cell2DArray.xCount)\n                targetIndex.x -= this.cell2DArray.xCount;\n            if (targetIndex.y < 0)\n                targetIndex.y += this.cell2DArray.yCount;\n            else if (targetIndex.y >= this.cell2DArray.yCount)\n                targetIndex.y -= this.cell2DArray.yCount;\n        }\n        else {\n            if (targetIndex.x < 0 || targetIndex.x >= this.cell2DArray.xCount ||\n                targetIndex.y < 0 || targetIndex.y >= this.cell2DArray.yCount)\n                return this.nullCell;\n        }\n        return this.cell2DArray.get2D(targetIndex.x, targetIndex.y);\n    }\n    setNeighborCells(referenceCell, neighborRange, loopAtEndOfScreen) {\n        for (let relativeX = -neighborRange; relativeX <= neighborRange; relativeX += 1) {\n            for (let relativeY = -neighborRange; relativeY <= neighborRange; relativeY += 1) {\n                referenceCell.setNeighborCell(relativeX, relativeY, this.getRelativePositionCell(referenceCell, relativeX, relativeY, loopAtEndOfScreen));\n            }\n        }\n    }\n}\n\n/**\n * (To be filled)\n */\nclass DrawableArray extends LoopableArray {\n    static drawFunction(value) {\n        value.draw();\n    }\n    /**\n     * Draws all child elements.\n     */\n    draw() {\n        this.loop(DrawableArray.drawFunction);\n    }\n}\n\n/**\n * (To be filled)\n */\nclass SteppableArray extends LoopableArray {\n    static stepFunction(value) {\n        value.step();\n    }\n    /**\n     * Steps all child elements.\n     */\n    step() {\n        this.loop(SteppableArray.stepFunction);\n    }\n}\n\n/**\n * (To be filled)\n */\nclass SpriteArray extends LoopableArray {\n}\nSpriteArray.prototype.step = SteppableArray.prototype.step;\nSpriteArray.prototype.draw = DrawableArray.prototype.draw;\n\n/**\n * (To be filled)\n */\nclass CleanableArray extends LoopableArray {\n    /**\n     *\n     * @param initialCapacity\n     */\n    constructor(initialCapacity) {\n        super(initialCapacity);\n        this.recentRemovedElements = new LoopableArray(initialCapacity);\n    }\n    /**\n     * Updates the variable 'isToBeRemoved'.\n     * If it has cleanable child elements, calls clean() recursively and\n     * removes the child elements which are to be removed.\n     */\n    clean() {\n        this.recentRemovedElements.clear();\n        let validElementCount = 0;\n        for (let i = 0; i < this.length; i += 1) {\n            this.array[i].clean();\n            if (this.array[i].isToBeRemoved) {\n                this.recentRemovedElements.push(this.array[i]);\n                continue;\n            }\n            this.array[validElementCount] = this.array[i];\n            validElementCount += 1;\n        }\n        this.length = validElementCount;\n    }\n}\n\n/**\n * (To be filled)\n */\nclass CleanableSpriteArray extends CleanableArray {\n}\nCleanableSpriteArray.prototype.draw = SpriteArray.prototype.draw;\nCleanableSpriteArray.prototype.step = SpriteArray.prototype.step;\n\n/**\n * Object pool which calls the provided function for every element when using & recyling.\n * Intended to use with the library deePool, but can also be used with another implementation.\n */\nclass ObjectPool {\n    /**\n     *\n     * @param naivePool - The pool object with use() and recycle(obj) methods.\n     * @param useProcess - The callback function which will be called in use().\n     * @param recycleProcess - The callback function which will be called in recycle().\n     */\n    constructor(naivePool, useProcess, recycleProcess) {\n        this.naivePool = naivePool;\n        this.useProcess = useProcess || ((object) => { });\n        this.recycleProcess = recycleProcess || ((object) => { });\n        this.recycle = (usedObject) => {\n            this.recycleProcess(usedObject);\n            this.naivePool.recycle(usedObject);\n        };\n    }\n    /**\n     * Returns an object which is currently not in use.\n     */\n    use() {\n        const newObject = this.naivePool.use();\n        this.useProcess(newObject);\n        return newObject;\n    }\n    /**\n     * Recycles all elements of the provided array.\n     * @param array\n     */\n    recycleAll(array) {\n        array.loop(this.recycle);\n    }\n}\n/**\n * Array of pooled objects. Recycles every removing object when clean() has been called.\n */\nclass PoolableArray extends CleanableArray {\n    constructor(pool, initialCapacity) {\n        super(initialCapacity);\n        this.pool = pool;\n    }\n    clean() {\n        super.clean();\n        this.recentRemovedElements.loop(this.pool.recycle);\n        this.recentRemovedElements.clear();\n    }\n}\n\n/**\n * (To be filled)\n */\nclass ScaleFactor {\n    /**\n     *\n     * @param p - p5ex instance.\n     * @param { number } [value = 1]\n     */\n    constructor(p, value = 1) {\n        this.p = p;\n        this.internalValue = value;\n        this.internalReciprocalValue = 1 / value;\n    }\n    /**\n     * The numeric value of the scale factor.\n     */\n    get value() {\n        return this.internalValue;\n    }\n    set value(v) {\n        if (v === 0) {\n            this.internalValue = 0.0001;\n            this.internalReciprocalValue = 10000;\n            return;\n        }\n        this.internalValue = v;\n        this.internalReciprocalValue = 1 / v;\n    }\n    /**\n     * The reciprocal value of the scale factor.\n     */\n    get reciprocalValue() {\n        return this.internalReciprocalValue;\n    }\n    /**\n     * Calls scale().\n     */\n    applyScale() {\n        this.p.currentRenderer.scale(this.internalValue);\n    }\n    /**\n     * Calls scale() with the reciprocal value.\n     */\n    cancel() {\n        this.p.currentRenderer.scale(this.internalReciprocalValue);\n    }\n}\n\n/**\n * (To be filled)\n */\nclass DrawerBuilder {\n    /**\n     *\n     * @param p\n     */\n    constructor(p) {\n        /**\n         * Parameter for drawing.\n         */\n        this.drawParam = {};\n        this.p = p;\n    }\n    /**\n     * @param element\n     * @chainable\n     */\n    setElement(element) {\n        this.element = element;\n        return this;\n    }\n    /**\n     * @param positionRef\n     * @chainable\n     */\n    setPositionRef(positionRef) {\n        this.drawParam.positionRef = positionRef;\n        return this;\n    }\n    /**\n     * @param offsetPositionRef\n     * @chainable\n     */\n    setOffsetPositionRef(offsetPositionRef) {\n        this.drawParam.offsetPositionRef = offsetPositionRef;\n        return this;\n    }\n    /**\n     * @param rotationAngleRef\n     * @chainable\n     */\n    setRotationAngleRef(rotationAngleRef) {\n        this.drawParam.rotationAngleRef = rotationAngleRef;\n        return this;\n    }\n    /**\n     * @param scaleFactorRef\n     * @chainable\n     */\n    setScaleFactorRef(scaleFactorRef) {\n        this.drawParam.scaleFactorRef = scaleFactorRef;\n        return this;\n    }\n    /**\n     * @param shapeColorRef\n     * @chainable\n     */\n    setShapeColorRef(shapeColorRef) {\n        this.drawParam.shapeColorRef = shapeColorRef;\n        return this;\n    }\n    /**\n     * @param alphaChannelRef\n     * @chainable\n     */\n    setAlphaChannelRef(alphaChannelRef) {\n        this.drawParam.alphaChannelRef = alphaChannelRef;\n        return this;\n    }\n    /**\n     * @param strokeWeightRef\n     * @chainable\n     */\n    setStrokeWeightRef(strokeWeightRef) {\n        this.drawParam.strokeWeightRef = strokeWeightRef;\n        return this;\n    }\n    /**\n     * @param textSizeRef\n     * @chainable\n     */\n    setTextSizeRef(textSizeRef) {\n        this.drawParam.textSizeRef = textSizeRef;\n        return this;\n    }\n    /**\n     * Builds a p5ex.Drawer instance.\n     */\n    build() {\n        return new Drawer(this.p, this.element, this.drawParam);\n    }\n}\n/**\n * (To be filled)\n */\nclass Drawer {\n    /**\n     *\n     * @param p\n     * @param element\n     * @param drawParam\n     */\n    constructor(p, element, drawParam) {\n        this.p = p;\n        this.set(element, drawParam);\n    }\n    /**\n     * (To be filled)\n     * @param element\n     * @param drawParam\n     */\n    set(element, drawParam) {\n        this.element = element;\n        this.position = drawParam.positionRef || this.p.createVector();\n        this.offsetPosition = drawParam.offsetPositionRef || this.p.createVector();\n        this.rotation = drawParam.rotationAngleRef || NumberContainer.NULL;\n        this.scaleFactor = drawParam.scaleFactorRef || new ScaleFactor(this.p);\n        this.shapeColor = drawParam.shapeColorRef || ShapeColor.UNDEFINED;\n        this.alphaChannel = drawParam.alphaChannelRef || NumberContainer.NULL;\n        this.strokeWeight = drawParam.strokeWeightRef || NumberContainer.NULL;\n        this.textSize = drawParam.textSizeRef || NumberContainer.NULL;\n        this.procedureList = this.createProcedureList(drawParam);\n        this.procedureListLength = this.procedureList.length;\n    }\n    /**\n     * Draws the content.\n     */\n    draw() {\n        for (let i = 0, len = this.procedureListLength; i < len; i += 1) {\n            this.procedureList[i](this);\n        }\n    }\n    drawElement(drawer) {\n        drawer.element.draw();\n    }\n    createProcedureList(drawParam) {\n        const procedureList = [];\n        if (drawParam.shapeColorRef) {\n            if (drawParam.alphaChannelRef)\n                procedureList.push(this.alphaColor);\n            else\n                procedureList.push(this.color);\n        }\n        if (drawParam.textSizeRef)\n            procedureList.push(this.applyTextSize);\n        if (drawParam.strokeWeightRef)\n            procedureList.push(this.applyStrokeWeight);\n        if (drawParam.positionRef) {\n            if (drawParam.offsetPositionRef)\n                procedureList.push(this.translateWithOffset);\n            else\n                procedureList.push(this.translate);\n        }\n        else if (drawParam.offsetPositionRef)\n            procedureList.push(this.translateOnlyOffset);\n        if (drawParam.scaleFactorRef)\n            procedureList.push(this.scale);\n        if (drawParam.rotationAngleRef)\n            procedureList.push(this.rotate);\n        procedureList.push(this.drawElement);\n        if (drawParam.rotationAngleRef)\n            procedureList.push(this.cancelRotate);\n        if (drawParam.scaleFactorRef)\n            procedureList.push(this.cancelScale);\n        if (drawParam.positionRef) {\n            if (drawParam.offsetPositionRef)\n                procedureList.push(this.cancelTranslateWithOffset);\n            else\n                procedureList.push(this.cancelTranslate);\n        }\n        else if (drawParam.offsetPositionRef)\n            procedureList.push(this.cancelTranslateOnlyOffset);\n        return procedureList;\n    }\n    translate(drawer) {\n        drawer.p.currentRenderer.translate(drawer.position.x, drawer.position.y);\n    }\n    cancelTranslate(drawer) {\n        drawer.p.currentRenderer.translate(-drawer.position.x, -drawer.position.y);\n    }\n    translateOnlyOffset(drawer) {\n        drawer.p.currentRenderer.translate(drawer.offsetPosition.x, drawer.offsetPosition.y);\n    }\n    cancelTranslateOnlyOffset(drawer) {\n        drawer.p.currentRenderer.translate(-drawer.offsetPosition.x, -drawer.offsetPosition.y);\n    }\n    translateWithOffset(drawer) {\n        drawer.p.currentRenderer.translate(drawer.position.x + drawer.offsetPosition.x, drawer.position.y + drawer.offsetPosition.y);\n    }\n    cancelTranslateWithOffset(drawer) {\n        drawer.p.currentRenderer.translate(-(drawer.position.x + drawer.offsetPosition.x), -(drawer.position.y + drawer.offsetPosition.y));\n    }\n    rotate(drawer) {\n        drawer.p.currentRenderer.rotate(drawer.rotation.value);\n    }\n    cancelRotate(drawer) {\n        drawer.p.currentRenderer.rotate(-drawer.rotation.value);\n    }\n    scale(drawer) {\n        if (drawer.scaleFactor.value === 1)\n            return;\n        drawer.scaleFactor.applyScale();\n    }\n    cancelScale(drawer) {\n        if (drawer.scaleFactor.value === 1)\n            return;\n        drawer.scaleFactor.cancel();\n    }\n    color(drawer) {\n        drawer.shapeColor.applyColor();\n    }\n    alphaColor(drawer) {\n        drawer.shapeColor.applyColor(drawer.alphaChannel.value);\n    }\n    applyStrokeWeight(drawer) {\n        drawer.p.currentRenderer.strokeWeight(drawer.strokeWeight.value);\n    }\n    applyTextSize(drawer) {\n        drawer.p.currentRenderer.textSize(drawer.textSize.value);\n    }\n}\n\n/**\n * (To be filled)\n */\nclass ShapeType {\n    /**\n     * @param drawShape\n     */\n    constructor(drawShape) {\n        this.drawShape = drawShape;\n    }\n}\nconst COS60 = 1 / 2;\nconst SIN60 = Math.sqrt(3) / 2;\n\n/**\n * Set of shape types.\n */\nconst ShapeTypes = {\n    CIRCLE: new ShapeType((renderer, size) => { renderer.ellipse(0, 0, size, size); }),\n    SQUARE: new ShapeType((renderer, size) => { renderer.rect(0, 0, size, size); }),\n    REGULAR_TRIANGLE: new ShapeType((renderer, size) => {\n        const radius = 0.5 * size;\n        renderer.triangle(radius, 0, -COS60 * radius, -SIN60 * radius, -COS60 * radius, +SIN60 * radius);\n    }),\n    REGULAR_TRIANGLE_UPWARD: new ShapeType((renderer, size) => {\n        const radius = 0.5 * size;\n        renderer.triangle(0, radius, -SIN60 * radius, -COS60 * radius, +SIN60 * radius, -COS60 * radius);\n    }),\n};\n\n/**\n * (To be filled)\n */\nclass ScalableShape {\n    /**\n     *\n     * @param p5exInstance\n     * @param shapeType - type chosen from p5ex.ShapeTypes\n     * @param {number} baseShapeSize\n     * @param {NumberContainer} [scaleFactorRef]\n     */\n    constructor(p5exInstance, shapeType, baseShapeSize, scaleFactorRef = new NumberContainer(1)) {\n        this.p = p5exInstance;\n        this.shapeType = shapeType;\n        this.baseShapeSize = baseShapeSize;\n        this.scaleFactorRef = scaleFactorRef;\n    }\n    /**\n     * Draws the shape.\n     */\n    draw() {\n        this.shapeType.drawShape(this.p, this.scaleFactorRef.value * this.baseShapeSize);\n    }\n}\n\n/**\n * (To be filled)\n */\nclass LineSegment {\n    constructor(p, x1, y1, x2, y2) {\n        this.p = p;\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n    }\n    draw() {\n        this.p.currentRenderer.line(this.x1, this.y1, this.x2, this.y2);\n    }\n}\n\n/**\n * (To be filled)\n */\nclass CircularArc {\n    constructor(p, centerPosition, diameter, startAngle, endAngle, isClockwise, startRatio, endRatio) {\n        this.p = p;\n        this.centerPosition = centerPosition;\n        this.diameter = diameter;\n        this.startAngle = startAngle;\n        this.endAngle = endAngle;\n        this.startRatio = startRatio;\n        this.endRatio = endRatio;\n        this.isClockwise = isClockwise;\n    }\n    get isClockwise() { return this._isClockwise; }\n    set isClockwise(flag) {\n        this._isClockwise = flag;\n        this.validate = flag ? validateClockwise : validateAntiClockwise;\n        this.drawTrimmedArc = flag ? drawClockwise : drawAntiClockwise;\n    }\n    draw() {\n        this.validate(this);\n        const angleDifference = this.endAngle.value - this.startAngle.value;\n        const start = this.startAngle.value +\n            this.startRatio.value * angleDifference;\n        const end = this.startAngle.value +\n            this.endRatio.value * angleDifference;\n        this.drawTrimmedArc(this.p, this.centerPosition, this.diameter.value, start, end);\n    }\n}\nfunction validateClockwise(arc) {\n    if (arc.startAngle.value > arc.endAngle.value)\n        arc.endAngle.value += arc.p.TWO_PI;\n}\nfunction validateAntiClockwise(arc) {\n    if (arc.startAngle.value < arc.endAngle.value)\n        arc.endAngle.value -= arc.p.TWO_PI;\n}\nfunction drawClockwise(p, centerPosition, diameter, trimmedStartAngle, trimmedEndAngle) {\n    p.currentRenderer.arc(centerPosition.x, centerPosition.y, diameter, diameter, trimmedStartAngle, trimmedEndAngle);\n}\nfunction drawAntiClockwise(p, centerPosition, diameter, trimmedStartAngle, trimmedEndAngle) {\n    p.currentRenderer.arc(centerPosition.x, centerPosition.y, diameter, diameter, trimmedEndAngle, trimmedStartAngle);\n}\n\n// temporal vectors for use in QuadraticBezierCurve.\nconst tmpMidPoint1 = dummyP5.createVector();\nconst tmpMidPoint2 = dummyP5.createVector();\n/**\n * Trimmable quadratic bezier curve.\n */\nclass QuadraticBezierCurve {\n    /**\n     *\n     * @param p\n     * @param startPoint\n     * @param controlPoint\n     * @param endPoint\n     * @param resolution\n     * @param startRatioRef\n     * @param endRatioRef\n     */\n    constructor(p, startPoint, controlPoint, endPoint, resolution, startRatioRef, endRatioRef) {\n\n        this.pointList = new Array(resolution + 1);\n        this.resolution = resolution;\n        this.startRatio = startRatioRef;\n        this.endRatio = endRatioRef;\n        this.p = p;\n        for (let i = 0; i <= resolution; i += 1) {\n            const ratio2 = i / resolution;\n            const ratio1 = 1 - ratio2;\n            tmpMidPoint1.set(ratio1 * startPoint.x + ratio2 * controlPoint.x, ratio1 * startPoint.y + ratio2 * controlPoint.y);\n            tmpMidPoint2.set(ratio1 * controlPoint.x + ratio2 * endPoint.x, ratio1 * controlPoint.y + ratio2 * endPoint.y);\n            this.pointList[i] = p.createVector(ratio1 * tmpMidPoint1.x + ratio2 * tmpMidPoint2.x, ratio1 * tmpMidPoint1.y + ratio2 * tmpMidPoint2.y);\n        }\n    }\n    /**\n     * Returns true if the provided control point candidate is valid.\n     * @param controlPoint - The control point candidate to be checked.\n     * @param startPoint - The start point of the bezier curve.\n     * @param endPoint - The start point of the bezier curve.\n     * @param minDistance - Minimum distance between the control point and the start/end point.\n     * @param minAngle - Minimum angle of the control point.\n     * @param maxAngle - Maximum angle of the control point.\n     * @static\n     */\n    static checkControlPoint(controlPoint, startPoint, endPoint, minDistance, minAngle, maxAngle) {\n        const minDistanceSquared = minDistance * minDistance;\n        if (distSq(controlPoint, startPoint) < minDistanceSquared)\n            return false;\n        if (distSq(controlPoint, endPoint) < minDistanceSquared)\n            return false;\n        const angle = Math.abs(angleDifference(getDirectionAngle(controlPoint, startPoint), getDirectionAngle(controlPoint, endPoint)));\n        if (angle < minAngle)\n            return false;\n        if (angle > maxAngle)\n            return false;\n        return true;\n    }\n    draw() {\n        const startIndex = Math.floor(this.startRatio.value * this.resolution);\n        const endIndex = Math.floor(this.endRatio.value * this.resolution);\n        const indexRemainder = this.endRatio.value * this.resolution - endIndex;\n        const renderer = this.p.currentRenderer;\n        const points = this.pointList;\n        renderer.beginShape();\n        for (let i = startIndex; i <= endIndex; i += 1) {\n            renderer.vertex(points[i].x, points[i].y);\n        }\n        if (indexRemainder > 0) {\n            renderer.vertex(points[endIndex].x + indexRemainder * (points[endIndex + 1].x - points[endIndex].x), points[endIndex].y + indexRemainder * (points[endIndex + 1].y - points[endIndex].y));\n        }\n        renderer.endShape();\n    }\n}\n\n/**\n * Draws a sine wave.\n * @param p\n * @param drawingLength\n * @param peakToPeakAmplitude\n * @param waveLength\n */\nfunction drawSineWave(p, drawingLength, peakToPeakAmplitude, waveLength) {\n    const renderer = p.currentRenderer;\n    const peakAmplitude = 0.5 * peakToPeakAmplitude;\n    let reachedEnd = false;\n    renderer.beginShape();\n    for (let x = 0; x <= drawingLength; x += 1) {\n        if (x > drawingLength)\n            reachedEnd = true;\n        renderer.vertex(reachedEnd ? drawingLength : x, -peakAmplitude * Math.sin(p.TWO_PI * x / waveLength));\n        if (reachedEnd)\n            break;\n    }\n    renderer.endShape();\n}\n/**\n * Set color to the specified pixel.\n * @param renderer - Instance of either p5 or p5.Graphics.\n * @param x - The x index of the pixel.\n * @param y - The y index of the pixel.\n * @param red - The red value (0 - 255).\n * @param green - The green value (0 - 255).\n * @param blue - The blue value (0 - 255).\n * @param pixelDensity - If not specified, renderer.pixelDensity() will be called.\n */\nfunction setPixel(renderer, x, y, red, green, blue, alpha, pixelDensity) {\n    const g = renderer;\n    const d = pixelDensity || g.pixelDensity();\n    for (let i = 0; i < d; i += 1) {\n        for (let j = 0; j < d; j += 1) {\n            const idx = 4 * ((y * d + j) * g.width * d + (x * d + i));\n            g.pixels[idx] = red;\n            g.pixels[idx + 1] = green;\n            g.pixels[idx + 2] = blue;\n            g.pixels[idx + 3] = alpha;\n        }\n    }\n}\n/**\n * Lerp color to the specified pixel. The alpha channel remains unchanged.\n * @param renderer - Instance of either p5 or p5.Graphics.\n * @param x - The x index of the pixel.\n * @param y - The y index of the pixel.\n * @param red - The red value (0 - 255).\n * @param green - The green value (0 - 255).\n * @param blue - The blue value (0 - 255).\n * @param pixelDensity - If not specified, renderer.pixelDensity() will be called.\n * @param lerpRatio - The lerp ratio (0 - 1). If 1, the color will be replaced.\n */\nfunction lerpPixel(renderer, x, y, red, green, blue, pixelDensity, lerpRatio = 1) {\n    const g = renderer;\n    const d = pixelDensity || g.pixelDensity();\n    for (let i = 0; i < d; i += 1) {\n        for (let j = 0; j < d; j += 1) {\n            const idx = 4 * ((y * d + j) * g.width * d + (x * d + i));\n            g.pixels[idx] = lerp(g.pixels[idx], red, lerpRatio);\n            g.pixels[idx + 1] = lerp(g.pixels[idx + 1], green, lerpRatio);\n            g.pixels[idx + 2] = lerp(g.pixels[idx + 2], blue, lerpRatio);\n            // g.pixels[idx + 3] = 255;\n        }\n    }\n}\n\n/**\n * Font class.\n */\nclass FontUnit {\n    /**\n     *\n     * @param p - p5ex instance.\n     * @param {string} name - The font name.\n     * @param {string} [filePath] - The file path of the font.\n     *     Not required if the font is already loaded (e.g. as a web font).\n     */\n    constructor(p, name, filePath) {\n        this.p = p;\n        this.filePath = filePath || null;\n        this.textFontArgument = name;\n    }\n    /**\n     * Loads the font file if the file path has been specified.\n     */\n    loadFile() {\n        if (this.filePath)\n            this.textFontArgument = this.p.loadFont(this.filePath);\n    }\n    /**\n     * Applies the font to the current renderer.\n     */\n    applyFont() {\n        this.p.currentRenderer.textFont(this.textFontArgument);\n    }\n}\n/**\n * Manager class of FontUnit.\n */\nclass FontManager {\n    /**\n     *\n     * @param p - p5ex instance.\n     */\n    constructor(p) {\n        this.p = p;\n        this.fontMap = new Map();\n    }\n    /**\n     * Registers a new font.\n     * @param p\n     * @param name\n     * @param filePath\n     * @chainable\n     */\n    register(name, filePath) {\n        this.fontMap.set(name, new FontUnit(this.p, name, filePath));\n        return this;\n    }\n    /**\n     * Calls loadFile() for each registered font. Should be called in preload().\n     */\n    loadAll() {\n        for (const font of this.fontMap.values()) {\n            font.loadFile();\n        }\n    }\n    /**\n     * Applies the specified font to the current renderer.\n     * @param {string} name - The font name.\n     */\n    applyFont(name) {\n        const font = this.fontMap.get(name);\n        if (font)\n            font.applyFont();\n    }\n}\n\n/**\n * (To be filled)\n */\nclass AngleQuantity {\n    /**\n     * Null object of AngleQuantity.\n     * @static\n     */\n    static get NULL() { return NULL$1; }\n    /**\n     *\n     * @param angle\n     * @param angleVelocity\n     */\n    constructor(angle = 0, angleVelocity = 0) {\n        this.angleReference = new NumberContainer(angle);\n        this.angleVelocityReference = new NumberContainer(angleVelocity);\n    }\n    /**\n     * Current angle value.\n     */\n    get angle() { return this.angleReference.value; }\n    set angle(v) { this.angleReference.value = v; }\n    /**\n     * Current anglular velocity value.\n     */\n    get angleVelocity() { return this.angleVelocityReference.value; }\n    set angleVelocity(v) { this.angleVelocityReference.value = v; }\n    /**\n     * Updates the angle.\n     */\n    step() {\n        this.angle += this.angleVelocity;\n    }\n}\nclass NullAngleQuantity extends AngleQuantity {\n    get angle() { return 0; }\n    set angle(v) { }\n    get angleVelocity() { return 0; }\n    set angleVelocity(v) { }\n    step() { }\n}\nconst NULL$1 = new NullAngleQuantity();\n\n/**\n * (To be filled)\n */\nclass KinematicQuantity {\n    constructor() {\n        this.position = new p5.Vector();\n        this.velocity = new p5.Vector();\n    }\n    /**\n     * Updates the position.\n     */\n    step() {\n        this.position.add(this.velocity);\n    }\n    /**\n     * Returns the current speed.\n     */\n    getSpeed() {\n        return this.velocity.mag();\n    }\n    /**\n     * Returns the current direction angle.\n     */\n    getDirection() {\n        return this.velocity.heading();\n    }\n    /**\n     * Adds the given value to the current speed.\n     * @param speedChange\n     */\n    addSpeed(speedChange) {\n        this.velocity.setMag(Math.max(0, this.velocity.mag() + speedChange));\n    }\n}\n\nconst temporalVector = dummyP5.createVector();\n/**\n * (To be filled)\n */\nclass PhysicsBody {\n    constructor() {\n        this.kinematicQuantity = new KinematicQuantity();\n        this.position = this.kinematicQuantity.position;\n        this.velocity = this.kinematicQuantity.velocity;\n        this.mass = 1;\n        this.collisionRadius = 0;\n        this.hasFriction = false;\n        this.decelerationFactor = 1;\n    }\n    /**\n     * X position.\n     */\n    get x() {\n        return this.position.x;\n    }\n    /**\n     * Y position.\n     */\n    get y() {\n        return this.position.y;\n    }\n    /**\n     * Z position.\n     */\n    get z() {\n        return this.position.z;\n    }\n    /**\n     * X velocity.\n     */\n    get vx() {\n        return this.velocity.x;\n    }\n    /**\n     * Y velocity.\n     */\n    get vy() {\n        return this.velocity.y;\n    }\n    /**\n     * Z velocity.\n     */\n    get vz() {\n        return this.velocity.z;\n    }\n    /**\n     * Returns the current speed.\n     */\n    getSpeed() {\n        return this.kinematicQuantity.getSpeed();\n    }\n    /**\n     * Returns the current direction angle.\n     */\n    getDirection() {\n        return this.kinematicQuantity.getDirection();\n    }\n    /**\n     * Sets the friction of the body.\n     * @param constant\n     */\n    setFriction(constant) {\n        if (constant === 0) {\n            this.hasFriction = false;\n            return;\n        }\n        this.hasFriction = true;\n        this.decelerationFactor = 1 - constant;\n    }\n    /**\n     * Constrains the current speed. Should be called every time if needed.\n     * @param maxSpeed\n     */\n    constrainSpeed(maxSpeed) {\n        if (this.velocity.magSq() > maxSpeed * maxSpeed)\n            this.velocity.setMag(maxSpeed);\n    }\n    /**\n     * Updates the body.\n     */\n    step() {\n        this.kinematicQuantity.step();\n        if (this.hasFriction) {\n            this.kinematicQuantity.velocity.mult(this.decelerationFactor);\n        }\n    }\n    /**\n     * Accelerates the body.\n     * @param x\n     * @param y\n     * @param z\n     */\n    accelerate(x, y, z) {\n        this.kinematicQuantity.velocity.add(x, y, z);\n    }\n    /**\n     * Apply the provided force to the body.\n     * @param force\n     */\n    applyForce(force) {\n        this.accelerate(force.x / this.mass, force.y / this.mass, force.z / this.mass);\n    }\n    /**\n     * Add the provided value to the speed of the body.\n     * @param speedChange\n     */\n    addSpeed(speedChange) {\n        this.kinematicQuantity.addSpeed(speedChange);\n    }\n    /**\n     * Returns true if the body collides the provided body.\n     * @param other\n     */\n    collides(other) {\n        return (distSq(this.position, other.position) <\n            this.collisionRadius * this.collisionRadius + other.collisionRadius * other.collisionRadius);\n    }\n    /**\n     * (To be filled)\n     * @param normalUnitVector\n     * @param restitution\n     */\n    bounce(normalUnitVector, restitution = 1) {\n        this.velocity.add(p5.Vector.mult(normalUnitVector, (1 + restitution) * p5.Vector.dot(this.velocity, p5.Vector.mult(normalUnitVector, -1))));\n    }\n    /**\n     * Applies attraction force to both this and the target body.\n     * @param {PhysicsBody} other - the other body to interact with\n     * @param {number} magnitudeFactor - the factor of magnitude other than the distance\n     * @param {number} minMag - the minimum magnitude\n     * @param {number} maxMag - the maximum magnitude\n     * @param {number} cutoffMag - does not apply force if magnitude is smaller than this\n     */\n    attractEachOther(other, magnitudeFactor, minMag = 0, maxMag, cutoffMag) {\n        const force = this.calculateAttractionForce(other.position, magnitudeFactor, minMag, maxMag, cutoffMag);\n        if (!force)\n            return;\n        this.applyForce(force);\n        force.mult(-1);\n        other.applyForce(force);\n    }\n    /**\n     * Applies attraction force to this body.\n     * @param {p5.Vector} targetPosition - the target position\n     * @param {number} magnitudeFactor - the factor of magnitude other than the distance\n     * @param {number} minMag - the minimum magnitude\n     * @param {number} maxMag - the maximum magnitude\n     * @param {number} cutoffMag - does not apply force if magnitude is smaller than this\n     */\n    attractToPoint(targetPosition, magnitudeFactor, minMag = 0, maxMag, cutoffMag) {\n        const force = this.calculateAttractionForce(targetPosition, magnitudeFactor, minMag, maxMag, cutoffMag);\n        if (!force)\n            return;\n        this.applyForce(force);\n    }\n    calculateAttractionForce(targetPosition, magnitudeFactor, minMag = 0, maxMag, cutoffMag) {\n        const tmpVec = temporalVector;\n        p5.Vector.sub(targetPosition, this.position, tmpVec); // set relative position\n        const distanceSquared = tmpVec.magSq();\n        let magnitude = Math.abs(magnitudeFactor) / distanceSquared;\n        if (cutoffMag && magnitude < cutoffMag)\n            return null;\n        if (maxMag)\n            magnitude = Math.min(Math.max(magnitude, minMag), maxMag);\n        else\n            magnitude = Math.max(magnitude, minMag);\n        tmpVec.setMag(magnitude); // set force\n        if (magnitudeFactor < 0)\n            tmpVec.mult(-1);\n        return tmpVec;\n    }\n}\n\n/**\n * Returns the 2D force vector which is to be applied to the load.\n * @param loadDirectionAngle - the direction angle from the fulcrum to the load\n * @param loadDistance - the distance between the fulcrum and the load\n * @param effortDistance - the distance between the fulcrum and the effort\n * @param effortForceMagnitude - the effort force magnitude\n * @param rotateClockwise - true if the load is to be rotated clockwise, otherwise false\n * @param target - the vector to receive the result. Will be newly created if not specified\n */\nfunction calculateLeverageForce(loadDirectionAngle, loadDistance, effortDistance, effortForceMagnitude, rotateClockwise, target) {\n    const force = target || dummyP5.createVector();\n    const forceDirectionAngle = loadDirectionAngle + (rotateClockwise ? -dummyP5.HALF_PI : dummyP5.HALF_PI);\n    force.set(Math.cos(forceDirectionAngle), Math.sin(forceDirectionAngle));\n    force.setMag(effortForceMagnitude * effortDistance / loadDistance); // load force\n    return force;\n}\n\n/**\n * (To be filled)\n */\nclass FrameCounter {\n    constructor() {\n        this.count = 0;\n    }\n    /**\n     * Resets the counter.\n     * @param count\n     */\n    resetCount(count = 0) {\n        this.count = count;\n        return this;\n    }\n    /**\n     * Increments the frame count.\n     */\n    step() {\n        this.count += 1;\n    }\n    /**\n     * Returns the mod.\n     * @param divisor\n     */\n    mod(divisor) {\n        return this.count % divisor;\n    }\n}\n\n/**\n * (To be filled)\n */\nclass TimedFrameCounter extends FrameCounter {\n    /**\n     * True if this counter is activated.\n     */\n    get isOn() { return this._isOn; }\n\n    /**\n     *\n     * @param durationFrameCount\n     * @param completeBehavior\n     */\n    constructor(durationFrameCount, completeBehavior = EMPTY_FUNCTION) {\n        super();\n        this._isOn = true;\n        this.completeBehavior = completeBehavior;\n        this.durationFrameCount = durationFrameCount;\n    }\n    /**\n     * Activate this counter.\n     * @param duration\n     * @chainable\n     */\n    on(duration) {\n        this._isOn = true;\n        if (duration)\n            this.durationFrameCount = duration;\n        return this;\n    }\n    /**\n     * Deactivate this counter.\n     * @chainable\n     */\n    off() {\n        this._isOn = false;\n        return this;\n    }\n    /**\n     * @override\n     */\n    step() {\n        if (!this._isOn)\n            return;\n        this.count += 1;\n        if (this.count > this.durationFrameCount) {\n            this.completeCycle();\n        }\n    }\n}\n\n/**\n * (To be filled)\n */\nclass LoopedFrameCounter extends TimedFrameCounter {\n    /**\n     *\n     * @param duration\n     * @param cycleCompleteBehavior\n     */\n    constructor(duration, cycleCompleteBehavior) {\n        super(duration, cycleCompleteBehavior);\n    }\n    /**\n     * @override\n     * @chainable\n     */\n    on(duration) {\n        super.on(duration);\n        return this;\n    }\n    /**\n     * @override\n     * @chainable\n     */\n    off() {\n        super.off();\n        return this;\n    }\n    /**\n     * @override\n     */\n    getProgressRatio() {\n        return this.count / this.durationFrameCount;\n    }\n    /**\n     * @override\n     */\n    completeCycle() {\n        this.completeBehavior();\n        this.count = 0;\n    }\n}\n\n/**\n * (To be filled)\n */\nclass NonLoopedFrameCounter extends TimedFrameCounter {\n    /**\n     * True if the given frame count duration has ellapsed already.\n     */\n    get isCompleted() { return this._isCompleted; }\n\n    /**\n     *\n     * @param durationFrameCount\n     * @param completeBehavior\n     */\n    constructor(durationFrameCount, completeBehavior) {\n        super(durationFrameCount, completeBehavior);\n        this._isCompleted = false;\n    }\n    /**\n     * @override\n     * @chainable\n     */\n    on(duration) {\n        super.on(duration);\n        return this;\n    }\n    /**\n     * @override\n     * @chainable\n     */\n    off() {\n        super.off();\n        return this;\n    }\n    /**\n     * @override\n     */\n    resetCount() {\n        super.resetCount();\n        this._isCompleted = false;\n        return this;\n    }\n    /**\n     * @override\n     */\n    getProgressRatio() {\n        return this._isCompleted ? 1 : this.count / this.durationFrameCount;\n    }\n    /**\n     * @override\n     */\n    completeCycle() {\n        this._isCompleted = true;\n        this._isOn = false;\n        this.completeBehavior();\n    }\n}\n\n/**\n * Holds a boolean value for each key which indicates if the key is currently down.\n */\nconst keyDown = new Map();\n/**\n * Begins to listen key events. Default behaviors for arrow keys will be prevented.\n */\nfunction listenKey() {\n    window.addEventListener('keydown', (event) => {\n        keyDown.set(event.key, true);\n        keyDown.set(event.code, true);\n        switch (event.key) {\n            case 'ArrowDown':\n            case 'ArrowUp':\n            case 'ArrowLeft':\n            case 'ArrowRight':\n                return false;\n            default:\n                return;\n        }\n    });\n    window.addEventListener('keyup', (event) => {\n        keyDown.set(event.key, false);\n        keyDown.set(event.code, false);\n        switch (event.key) {\n            case 'ArrowDown':\n            case 'ArrowUp':\n            case 'ArrowLeft':\n            case 'ArrowRight':\n                return false;\n            default:\n                return;\n        }\n    });\n}\n\n/**\n * Returns true if the mouse cursor is on the canvas.\n * @param p - p5ex instance.\n */\nfunction mouseOnCanvas(p) {\n    if (p.mouseX < 0)\n        return false;\n    if (p.mouseX > p.width)\n        return false;\n    if (p.mouseY < 0)\n        return false;\n    if (p.mouseY > p.height)\n        return false;\n    return true;\n}\n\n/**\n * Extension of p5 class.\n */\nclass p5exClass extends p5 {\n    /**\n     * Sets the current renderer object.\n     * @param renderer\n     */\n    setCurrentRenderer(renderer) {\n        this.currentRenderer = renderer;\n    }\n    /**\n      * The non-scaled width of the canvas.\n      */\n    get nonScaledWidth() {\n        return this.scalableCanvas.nonScaledWidth;\n    }\n    /**\n     * The non-scaled height of the canvas.\n     */\n    get nonScaledHeight() {\n        return this.scalableCanvas.nonScaledHeight;\n    }\n\n    /**\n     * The ideal frame rate which was set by setFrameRate().\n     */\n    get idealFrameRate() { return this._idealFrameRate; }\n    /**\n     * Anglular displacement in radians per frame which corresponds to 1 cycle per second.\n     * Set by setFrameRate().\n     */\n    get unitAngleSpeed() { return this._unitAngleSpeed; }\n    /**\n     * Positional displacement per frame which corresponds to 1 unit length per second.\n     * Set by setFrameRate().\n     */\n    get unitSpeed() { return this._unitSpeed; }\n    /**\n     * Change of speed per frame which corresponds to 1 unit speed per second.\n     * Set by setFrameRate().\n     */\n    get unitAccelerationMagnitude() { return this._unitAccelerationMagnitude; }\n    /**\n     * Constructor of class p5ex.\n     * @param sketch\n     * @param node\n     * @param sync\n     */\n    constructor(sketch, node, sync) {\n        super(sketch, typeof node === 'string' ? document.getElementById(node) || undefined : node, sync);\n        if (!node || typeof node === 'boolean') {\n            this.node = document.body;\n        }\n        else {\n            this.node = typeof node === 'string' ? document.getElementById(node) || document.body : node;\n        }\n        this.currentRenderer = this;\n        this.maxCanvasRegion = {\n            width: 0,\n            height: 0,\n            getShortSideLength() { return Math.min(this.width, this.height); },\n        };\n        this.updateMaxCanvasRegion();\n        this.setFrameRate();\n    }\n    /**\n     * Calls frameRate() and sets variables related to the frame rate.\n     * @param {number} [fps=60] - The ideal frame rate per second.\n     */\n    setFrameRate(fps = 60) {\n        this.frameRate(fps);\n        if (fps) {\n            this._idealFrameRate = fps;\n            this._unitAngleSpeed = 2 * Math.PI / this._idealFrameRate;\n            this._unitSpeed = 1 / this._idealFrameRate;\n            this._unitAccelerationMagnitude = this._unitSpeed / this._idealFrameRate;\n        }\n        return this;\n    }\n    /**\n     * Updates the value of the variable maxCanvasRegion.\n     */\n    updateMaxCanvasRegion() {\n        this.maxCanvasRegion.width = this.windowWidth;\n        this.maxCanvasRegion.height = this.windowHeight;\n        if (this.node === document.body)\n            return;\n        const containerRect = this.node.getBoundingClientRect();\n        this.maxCanvasRegion.width = containerRect.width;\n        this.maxCanvasRegion.height = containerRect.height;\n    }\n    /**\n     * Create an instance of ScalableCanvas. This includes calling of createCanvas().\n     * @param {ScalableCanvasType} type - Type chosen from p5ex.ScalableCanvasTypes.\n     * @param {ScalableCanvasParameters} [parameters] - Parameters for type CUSTOM.\n     * @param {string} [rendererType] - Either P2D or WEBGL.\n     */\n    createScalableCanvas(type, parameters, rendererType) {\n        this.scalableCanvasType = type;\n        this.scalableCanvas = new ScalableCanvas(this, this.createScalableCanvasParameter(type, parameters), this.node, rendererType);\n    }\n    /**\n     * Resizes the ScalableCanvas. Does not work on OpenProcessing.\n     * @param {ScalableCanvasType} [type] - Type chosen from p5ex.ScalableCanvasTypes.\n     *     If undefined, the last used type will be used again.\n     * @param {ScalableCanvasParameters} [parameters] - Parameters for type CUSTOM.\n     */\n    resizeScalableCanvas(type, parameters) {\n        this.scalableCanvas.resize(this.createScalableCanvasParameter(type || this.scalableCanvasType, parameters));\n    }\n    createScalableCanvasParameter(type, parameters) {\n        this.updateMaxCanvasRegion();\n        const maxShortSide = this.maxCanvasRegion.getShortSideLength();\n        switch (type) {\n            case ScalableCanvasTypes.SQUARE640x640:\n                return {\n                    scaledWidth: maxShortSide,\n                    scaledHeight: maxShortSide,\n                    nonScaledShortSideLength: 640,\n                };\n            case ScalableCanvasTypes.RECT640x480:\n                return {\n                    scaledWidth: maxShortSide,\n                    scaledHeight: 0.75 * maxShortSide,\n                    nonScaledShortSideLength: 480,\n                };\n            case ScalableCanvasTypes.FULL:\n                return {\n                    scaledWidth: this.maxCanvasRegion.width,\n                    scaledHeight: this.maxCanvasRegion.height,\n                    nonScaledShortSideLength: 640,\n                };\n            default:\n                return parameters || ScalableCanvas.DUMMY_PARAMETERS;\n        }\n    }\n}\n\nexport { p5exClass, loopArray, loopArrayBackwards, roundRobin, nestedLoopJoin, LoopableArray, EMPTY_FUNCTION, distSq, multiplyMatrixAndArray, angleDifference, getDirectionAngle, lerp, randomBetween, randomInt, randomIntBetween, getRandom, popRandom, randomSign, NumberContainer, WeightedRandomSelector, easeLinear, easeOutQuad, easeOutCubic, easeOutQuart, easeOutBack, getEasingFunction, dummyP5, Region, RectangleRegion, ScalableCanvas, ScalableCanvasTypes, ScreenEffect, ScreenShake, ScreenFlash, AlphaBackground, mouseIsInCanvas, TwoDimensionalArray, NaiveEdge, NaiveCell, NullCell, Grid, DrawableArray, SteppableArray, SpriteArray, CleanableArray, CleanableSpriteArray, ObjectPool, PoolableArray, ShapeColor, RandomShapeColor, setIlluminant, cielabColor, cielchColor, Illuminants, degamma, subtractColor, hsbColor, Drawer, DrawerBuilder, ShapeType, ShapeTypes, ScalableShape, LineSegment, CircularArc, QuadraticBezierCurve, drawSineWave, setPixel, lerpPixel, FontUnit, FontManager, ScaleFactor, AngleQuantity, KinematicQuantity, PhysicsBody, calculateLeverageForce, FrameCounter, LoopedFrameCounter, NonLoopedFrameCounter, keyDown, listenKey, mouseOnCanvas };\n"],"names":[],"mappings":";;;;;;;;;;;;;AAWA;;;AAGA,MAAM,MAAM,CAAC;CACZ;;;;AAID,MAAM,eAAe,SAAS,MAAM,CAAC;IACjC,IAAI,KAAK,GAAG,EAAE,OAAO,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,aAAa,CAAC,EAAE;IAChE,IAAI,MAAM,GAAG,EAAE,OAAO,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,YAAY,CAAC,EAAE;IACjE,IAAI,IAAI,GAAG,EAAE,OAAO,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,EAAE;IAC/C,WAAW,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,MAAM,GAAG,CAAC,EAAE;QACpC,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,aAAa,GAAG,EAAE,GAAG,MAAM,CAAC;QACjC,IAAI,CAAC,YAAY,GAAG,EAAE,GAAG,MAAM,CAAC;QAChC,IAAI,CAAC,cAAc,GAAG,EAAE,GAAG,MAAM,CAAC;QAClC,IAAI,CAAC,eAAe,GAAG,EAAE,GAAG,MAAM,CAAC;KACtC;IACD,QAAQ,CAAC,QAAQ,EAAE,MAAM,GAAG,CAAC,EAAE;QAC3B,QAAQ,QAAQ,CAAC,CAAC,IAAI,IAAI,CAAC,aAAa,GAAG,MAAM,IAAI,QAAQ,CAAC,CAAC,IAAI,IAAI,CAAC,cAAc,GAAG,MAAM;YAC3F,QAAQ,CAAC,CAAC,IAAI,IAAI,CAAC,YAAY,GAAG,MAAM,IAAI,QAAQ,CAAC,CAAC,IAAI,IAAI,CAAC,eAAe,GAAG,MAAM,EAAE;KAChG;IACD,SAAS,CAAC,QAAQ,EAAE,MAAM,GAAG,CAAC,EAAE;QAC5B,IAAI,QAAQ,CAAC,CAAC,GAAG,IAAI,CAAC,aAAa,GAAG,MAAM;YACxC,QAAQ,CAAC,CAAC,GAAG,IAAI,CAAC,aAAa,GAAG,MAAM,CAAC;aACxC,IAAI,QAAQ,CAAC,CAAC,GAAG,IAAI,CAAC,cAAc,GAAG,MAAM;YAC9C,QAAQ,CAAC,CAAC,GAAG,IAAI,CAAC,cAAc,GAAG,MAAM,CAAC;QAC9C,IAAI,QAAQ,CAAC,CAAC,GAAG,IAAI,CAAC,YAAY,GAAG,MAAM;YACvC,QAAQ,CAAC,CAAC,GAAG,IAAI,CAAC,YAAY,GAAG,MAAM,CAAC;aACvC,IAAI,QAAQ,CAAC,CAAC,GAAG,IAAI,CAAC,eAAe,GAAG,MAAM;YAC/C,QAAQ,CAAC,CAAC,GAAG,IAAI,CAAC,eAAe,GAAG,MAAM,CAAC;KAClD;CACJ;;;;;;;AAOD,MAAM,cAAc,CAAC;IACjB,WAAW,CAAC,UAAU,EAAE,SAAS,EAAE,IAAI,EAAE,YAAY,EAAE;QACnD,IAAI,CAAC,CAAC,GAAG,UAAU,CAAC;QACpB,IAAI,CAAC,aAAa,GAAG,UAAU,CAAC,YAAY,CAAC,SAAS,CAAC,WAAW,EAAE,SAAS,CAAC,YAAY,EAAE,YAAY,CAAC,CAAC;QAC1G,IAAI,IAAI,CAAC,aAAa,IAAI,QAAQ,IAAI,IAAI,CAAC,aAAa,EAAE;YACtD,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;SACnC;QACD,IAAI,CAAC,MAAM,GAAG,IAAI,eAAe,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;QAC9C,IAAI,CAAC,wBAAwB,GAAG,SAAS,CAAC,wBAAwB,CAAC;QACnE,IAAI,CAAC,UAAU,EAAE,CAAC;KACrB;;;;;IAKD,IAAI,WAAW,GAAG;QACd,OAAO,IAAI,CAAC,YAAY,CAAC;KAC5B;;;;IAID,IAAI,cAAc,GAAG;QACjB,OAAO,IAAI,CAAC,eAAe,CAAC;KAC/B;;;;IAID,IAAI,eAAe,GAAG;QAClB,OAAO,IAAI,CAAC,gBAAgB,CAAC;KAChC;;;;IAID,IAAI,WAAW,GAAG;QACd,OAAO,IAAI,CAAC,YAAY,CAAC;KAC5B;;;;;IAKD,MAAM,CAAC,SAAS,EAAE;QACd,IAAI,CAAC,CAAC,CAAC,YAAY,CAAC,SAAS,CAAC,WAAW,EAAE,SAAS,CAAC,YAAY,CAAC,CAAC;QACnE,IAAI,CAAC,wBAAwB,GAAG,SAAS,CAAC,wBAAwB,CAAC;QACnE,IAAI,CAAC,UAAU,EAAE,CAAC;KACrB;;;;IAID,UAAU,GAAG;QACT,MAAM,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC;QACjB,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC,wBAAwB,CAAC;QAChF,IAAI,CAAC,oBAAoB,GAAG,CAAC,GAAG,IAAI,CAAC,YAAY,CAAC;QAClD,IAAI,CAAC,eAAe,GAAG,CAAC,CAAC,KAAK,GAAG,IAAI,CAAC,YAAY,CAAC;QACnD,IAAI,CAAC,gBAAgB,GAAG,CAAC,CAAC,MAAM,GAAG,IAAI,CAAC,YAAY,CAAC;QACrD,IAAI,CAAC,YAAY,GAAG,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,MAAM,CAAC;QACvC,IAAI,CAAC,MAAM,CAAC,cAAc,GAAG,IAAI,CAAC,eAAe,CAAC;QAClD,IAAI,CAAC,MAAM,CAAC,eAAe,GAAG,IAAI,CAAC,gBAAgB,CAAC;KACvD;;;;;IAKD,KAAK,GAAG;QACJ,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;KACnC;;;;IAID,WAAW,GAAG;QACV,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,oBAAoB,CAAC,CAAC;KAC3C;;;;;;IAMD,mBAAmB,CAAC,YAAY,EAAE;QAC9B,OAAO,YAAY,GAAG,IAAI,CAAC,YAAY,CAAC;KAC3C;CACJ;AACD,cAAc,CAAC,gBAAgB,GAAG;IAC9B,WAAW,EAAE,GAAG;IAChB,YAAY,EAAE,GAAG;IACjB,wBAAwB,EAAE,GAAG;CAChC,CAAC;;;;;;AAMF,MAAM,mBAAmB,GAAG;IACxB,aAAa,EAAE,eAAe;IAC9B,WAAW,EAAE,aAAa;IAC1B,IAAI,EAAE,MAAM;IACZ,MAAM,EAAE,QAAQ;CACnB,CAAC;;AAEF,MAAM,eAAe,CAAC;IAClB,WAAW,CAAC,CAAC,EAAE,OAAO,EAAE;QACpB,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC;QACX,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;KAC1B;IACD,MAAM,GAAG;QACL,IAAI,CAAC,CAAC,CAAC,eAAe,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;KAC/C;IACD,IAAI,GAAG;QACH,IAAI,CAAC,CAAC,CAAC,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;KAC7C;CACJ;AACD,MAAM,WAAW,CAAC;IACd,WAAW,CAAC,CAAC,EAAE;QACX,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC;KACd;IACD,MAAM,GAAG;QACL,IAAI,CAAC,CAAC,CAAC,eAAe,CAAC,QAAQ,EAAE,CAAC;KACrC;IACD,IAAI,GAAG;QACH,IAAI,CAAC,CAAC,CAAC,eAAe,CAAC,MAAM,EAAE,CAAC;KACnC;CACJ;AACD,MAAM,kBAAkB,CAAC;IACrB,MAAM,GAAG;KACR;IACD,IAAI,GAAG;KACN;CACJ;AACD,MAAM,cAAc,CAAC;IACjB,WAAW,CAAC,CAAC,EAAE,CAAC,EAAE,eAAe,GAAG,GAAG,EAAE;QACrC,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC;QACX,MAAM,KAAK,GAAG,EAAE,CAAC;QACjB,KAAK,IAAI,WAAW,GAAG,CAAC,EAAE,WAAW,GAAG,eAAe,EAAE,WAAW,IAAI,CAAC,EAAE;YACvE,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,GAAG,WAAW,IAAI,eAAe,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;SAC1G;QACD,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC;QACxB,IAAI,CAAC,QAAQ,GAAG,eAAe,GAAG,CAAC,CAAC;KACvC;IACD,MAAM,CAAC,UAAU,EAAE;QACf,IAAI,CAAC,CAAC,CAAC,eAAe,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC,CAAC;KAC5D;IACD,IAAI,CAAC,UAAU,EAAE;QACb,IAAI,CAAC,CAAC,CAAC,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC,CAAC;KAC1D;IACD,QAAQ,CAAC,UAAU,EAAE;QACjB,OAAO,IAAI,CAAC,UAAU,CAAC,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,UAAU,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC;KACrH;CACJ;AACD,SAAS,SAAS,CAAC,CAAC,EAAE,OAAO,EAAE,YAAY,EAAE,eAAe,EAAE;IAC1D,IAAI,CAAC,CAAC,IAAI,OAAO,KAAK,SAAS;QAC3B,OAAO,IAAI,kBAAkB,EAAE,CAAC;IACpC,IAAI,OAAO,KAAK,IAAI;QAChB,OAAO,IAAI,WAAW,CAAC,CAAC,CAAC,CAAC;IAC9B,IAAI,YAAY;QACZ,OAAO,IAAI,cAAc,CAAC,CAAC,EAAE,OAAO,EAAE,eAAe,CAAC,CAAC;IAC3D,OAAO,IAAI,eAAe,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC;CAC1C;;;;AAID,MAAM,UAAU,CAAC;;;;;;;;;IASb,WAAW,CAAC,CAAC,EAAE,WAAW,EAAE,SAAS,EAAE,YAAY,EAAE,eAAe,EAAE;QAClE,IAAI,CAAC,WAAW,GAAG,SAAS,CAAC,CAAC,EAAE,WAAW,EAAE,YAAY,EAAE,eAAe,CAAC,CAAC;QAC5E,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC,CAAC,EAAE,SAAS,EAAE,YAAY,EAAE,eAAe,CAAC,CAAC;KAC3E;;;;;IAKD,UAAU,CAAC,UAAU,EAAE;QACnB,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;QACpC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;KACnC;CACJ;;;;;AAKD,UAAU,CAAC,SAAS,GAAG,IAAI,UAAU,CAAC,SAAS,EAAE,SAAS,EAAE,SAAS,CAAC,CAAC;;;;;AAKvE,MAAM,cAAc,GAAG,MAAM,GAAG,CAAC;;;;AAIjC,MAAM,eAAe,GAAG,GAAG,GAAG,IAAI,CAAC,EAAE,CAAC;;AAEtC,MAAM,OAAO,GAAG,IAAI,EAAE,CAAC,CAAC,CAAC,KAAK;IAC1B,CAAC,CAAC,KAAK,GAAG,MAAM;QACZ,CAAC,CAAC,QAAQ,EAAE,CAAC;KAChB,CAAC;CACL,CAAC,CAAC;AACH,AA8BA,MAAM,MAAM,GAAG,CAAC,GAAG,IAAI,CAAC,EAAE,CAAC;AAC3B,AAqBA;AACA,MAAM,WAAW,GAAG,OAAO,CAAC,YAAY,EAAE,CAAC;AAC3C,MAAM,WAAW,GAAG,OAAO,CAAC,YAAY,EAAE,CAAC;AAC3C,AAwBA;;;AAGA,SAAS,SAAS,CAAC,MAAM,EAAE;IACvB,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,MAAM,CAAC,CAAC;CAC7C;AACD,AA4eA;AACA,SAAS,gBAAgB,CAAC,KAAK,EAAE,QAAQ,EAAE,WAAW,EAAE;IACpD,IAAI,CAAC,GAAG,CAAC,CAAC;IACV,OAAO,CAAC,GAAG,WAAW,EAAE;QACpB,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,KAAK,CAAC,CAAC;QAC7B,CAAC,IAAI,CAAC,CAAC;KACV;CACJ;AACD,AAQA,SAAS,yBAAyB,CAAC,KAAK,EAAE,QAAQ,EAAE,WAAW,EAAE;;IAE7D,OAAO,WAAW,EAAE,EAAE;QAClB,QAAQ,CAAC,KAAK,CAAC,WAAW,CAAC,EAAE,WAAW,EAAE,KAAK,CAAC,CAAC;KACpD;CACJ;AACD,AAQA;;;;;;;AAOA,SAAS,iBAAiB,CAAC,KAAK,EAAE,QAAQ,EAAE,WAAW,EAAE;IACrD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,GAAG,WAAW,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,IAAI,CAAC,EAAE;QACpD,KAAK,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,WAAW,EAAE,CAAC,IAAI,CAAC,EAAE;YACzC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;SAChC;KACJ;CACJ;AACD,AAQA;;;;;;AAMA,SAAS,qBAAqB,CAAC,KAAK,EAAE,UAAU,EAAE,QAAQ,EAAE,WAAW,EAAE,gBAAgB,EAAE;IACvF,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,WAAW,EAAE,CAAC,IAAI,CAAC,EAAE;QACrC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,gBAAgB,EAAE,CAAC,IAAI,CAAC,EAAE;YAC1C,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;SACrC;KACJ;CACJ;AACD,AASA;;;;;;;;;AASA,MAAM,aAAa,CAAC;;;;IAIhB,WAAW,CAAC,eAAe,GAAG,GAAG,EAAE;;QAE/B,IAAI,CAAC,KAAK,GAAG,IAAI,KAAK,CAAC,eAAe,CAAC,CAAC;QACxC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;KACnB;;;;;;;IAOD,GAAG,CAAC,KAAK,EAAE;QACP,OAAO,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;KAC5B;;;;;;IAMD,OAAO,GAAG;QACN,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;KACtC;;;;;IAKD,IAAI,CAAC,OAAO,EAAE;QACV,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,OAAO,CAAC;QAClC,IAAI,CAAC,MAAM,IAAI,CAAC,CAAC;QACjB,OAAO,IAAI,CAAC,MAAM,CAAC;KACtB;;;;;IAKD,YAAY,CAAC,KAAK,EAAE,WAAW,GAAG,KAAK,CAAC,MAAM,EAAE;QAC5C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,WAAW,EAAE,CAAC,IAAI,CAAC,EAAE;YACrC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;SAC1C;QACD,IAAI,CAAC,MAAM,IAAI,WAAW,CAAC;QAC3B,OAAO,IAAI,CAAC,MAAM,CAAC;KACtB;;;;;IAKD,OAAO,CAAC,kBAAkB,EAAE;QACxB,OAAO,IAAI,CAAC,YAAY,CAAC,kBAAkB,CAAC,KAAK,EAAE,kBAAkB,CAAC,MAAM,CAAC,CAAC;KACjF;;;;;;IAMD,GAAG,GAAG;QACF,IAAI,CAAC,MAAM,IAAI,CAAC,CAAC;QACjB,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;KAClC;;;;IAID,KAAK,GAAG;QACJ,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;KACnB;;;;;;;;;;;IAWD,IAAI,CAAC,QAAQ,EAAE;QACX,gBAAgB,CAAC,IAAI,CAAC,KAAK,EAAE,QAAQ,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;KACvD;;;;;IAKD,aAAa,CAAC,QAAQ,EAAE;QACpB,yBAAyB,CAAC,IAAI,CAAC,KAAK,EAAE,QAAQ,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;KAChE;;;;;;;;;;IAUD,UAAU,CAAC,QAAQ,EAAE;QACjB,iBAAiB,CAAC,IAAI,CAAC,KAAK,EAAE,QAAQ,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;KACxD;;;;;;IAMD,cAAc,CAAC,UAAU,EAAE,QAAQ,EAAE;QACjC,qBAAqB,CAAC,IAAI,CAAC,KAAK,EAAE,UAAU,CAAC,KAAK,EAAE,QAAQ,EAAE,IAAI,CAAC,MAAM,EAAE,UAAU,CAAC,MAAM,CAAC,CAAC;KACjG;CACJ;AACD,AAuMA;;;;AAIA,MAAM,aAAa,SAAS,aAAa,CAAC;IACtC,OAAO,YAAY,CAAC,KAAK,EAAE;QACvB,KAAK,CAAC,IAAI,EAAE,CAAC;KAChB;;;;IAID,IAAI,GAAG;QACH,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,YAAY,CAAC,CAAC;KACzC;CACJ;;;;;AAKD,MAAM,cAAc,SAAS,aAAa,CAAC;IACvC,OAAO,YAAY,CAAC,KAAK,EAAE;QACvB,KAAK,CAAC,IAAI,EAAE,CAAC;KAChB;;;;IAID,IAAI,GAAG;QACH,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,YAAY,CAAC,CAAC;KAC1C;CACJ;;;;;AAKD,MAAM,WAAW,SAAS,aAAa,CAAC;CACvC;AACD,WAAW,CAAC,SAAS,CAAC,IAAI,GAAG,cAAc,CAAC,SAAS,CAAC,IAAI,CAAC;AAC3D,WAAW,CAAC,SAAS,CAAC,IAAI,GAAG,aAAa,CAAC,SAAS,CAAC,IAAI,CAAC;;;;;AAK1D,MAAM,cAAc,SAAS,aAAa,CAAC;;;;;IAKvC,WAAW,CAAC,eAAe,EAAE;QACzB,KAAK,CAAC,eAAe,CAAC,CAAC;QACvB,IAAI,CAAC,qBAAqB,GAAG,IAAI,aAAa,CAAC,eAAe,CAAC,CAAC;KACnE;;;;;;IAMD,KAAK,GAAG;QACJ,IAAI,CAAC,qBAAqB,CAAC,KAAK,EAAE,CAAC;QACnC,IAAI,iBAAiB,GAAG,CAAC,CAAC;QAC1B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,EAAE;YACrC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC;YACtB,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,aAAa,EAAE;gBAC7B,IAAI,CAAC,qBAAqB,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC/C,SAAS;aACZ;YACD,IAAI,CAAC,KAAK,CAAC,iBAAiB,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YAC9C,iBAAiB,IAAI,CAAC,CAAC;SAC1B;QACD,IAAI,CAAC,MAAM,GAAG,iBAAiB,CAAC;KACnC;CACJ;;;;;AAKD,MAAM,oBAAoB,SAAS,cAAc,CAAC;CACjD;AACD,oBAAoB,CAAC,SAAS,CAAC,IAAI,GAAG,WAAW,CAAC,SAAS,CAAC,IAAI,CAAC;AACjE,oBAAoB,CAAC,SAAS,CAAC,IAAI,GAAG,WAAW,CAAC,SAAS,CAAC,IAAI,CAAC;AACjE,AAwbA;;AAEA,MAAM,YAAY,GAAG,OAAO,CAAC,YAAY,EAAE,CAAC;AAC5C,MAAM,YAAY,GAAG,OAAO,CAAC,YAAY,EAAE,CAAC;AAC5C,AAgSA;AACA,MAAM,cAAc,GAAG,OAAO,CAAC,YAAY,EAAE,CAAC;AAC9C,AAiMA;;;;AAIA,MAAM,YAAY,CAAC;IACf,WAAW,GAAG;QACV,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC;KAClB;;;;;IAKD,UAAU,CAAC,KAAK,GAAG,CAAC,EAAE;QAClB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,OAAO,IAAI,CAAC;KACf;;;;IAID,IAAI,GAAG;QACH,IAAI,CAAC,KAAK,IAAI,CAAC,CAAC;KACnB;;;;;IAKD,GAAG,CAAC,OAAO,EAAE;QACT,OAAO,IAAI,CAAC,KAAK,GAAG,OAAO,CAAC;KAC/B;CACJ;;;;;AAKD,MAAM,iBAAiB,SAAS,YAAY,CAAC;;;;IAIzC,IAAI,IAAI,GAAG,EAAE,OAAO,IAAI,CAAC,KAAK,CAAC,EAAE;;;;;;;IAOjC,WAAW,CAAC,kBAAkB,EAAE,gBAAgB,GAAG,cAAc,EAAE;QAC/D,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;QAClB,IAAI,CAAC,gBAAgB,GAAG,gBAAgB,CAAC;QACzC,IAAI,CAAC,kBAAkB,GAAG,kBAAkB,CAAC;KAChD;;;;;;IAMD,EAAE,CAAC,QAAQ,EAAE;QACT,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;QAClB,IAAI,QAAQ;YACR,IAAI,CAAC,kBAAkB,GAAG,QAAQ,CAAC;QACvC,OAAO,IAAI,CAAC;KACf;;;;;IAKD,GAAG,GAAG;QACF,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,OAAO,IAAI,CAAC;KACf;;;;IAID,IAAI,GAAG;QACH,IAAI,CAAC,IAAI,CAAC,KAAK;YACX,OAAO;QACX,IAAI,CAAC,KAAK,IAAI,CAAC,CAAC;QAChB,IAAI,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,kBAAkB,EAAE;YACtC,IAAI,CAAC,aAAa,EAAE,CAAC;SACxB;KACJ;CACJ;AACD,AA2CA;;;;AAIA,MAAM,qBAAqB,SAAS,iBAAiB,CAAC;;;;IAIlD,IAAI,WAAW,GAAG,EAAE,OAAO,IAAI,CAAC,YAAY,CAAC,EAAE;;;;;;;IAO/C,WAAW,CAAC,kBAAkB,EAAE,gBAAgB,EAAE;QAC9C,KAAK,CAAC,kBAAkB,EAAE,gBAAgB,CAAC,CAAC;QAC5C,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;KAC7B;;;;;IAKD,EAAE,CAAC,QAAQ,EAAE;QACT,KAAK,CAAC,EAAE,CAAC,QAAQ,CAAC,CAAC;QACnB,OAAO,IAAI,CAAC;KACf;;;;;IAKD,GAAG,GAAG;QACF,KAAK,CAAC,GAAG,EAAE,CAAC;QACZ,OAAO,IAAI,CAAC;KACf;;;;IAID,UAAU,GAAG;QACT,KAAK,CAAC,UAAU,EAAE,CAAC;QACnB,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;QAC1B,OAAO,IAAI,CAAC;KACf;;;;IAID,gBAAgB,GAAG;QACf,OAAO,IAAI,CAAC,YAAY,GAAG,CAAC,GAAG,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,kBAAkB,CAAC;KACvE;;;;IAID,aAAa,GAAG;QACZ,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;QACzB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,IAAI,CAAC,gBAAgB,EAAE,CAAC;KAC3B;CACJ;AACD,AAoDA;;;;AAIA,MAAM,SAAS,SAAS,EAAE,CAAC;;;;;IAKvB,kBAAkB,CAAC,QAAQ,EAAE;QACzB,IAAI,CAAC,eAAe,GAAG,QAAQ,CAAC;KACnC;;;;IAID,IAAI,cAAc,GAAG;QACjB,OAAO,IAAI,CAAC,cAAc,CAAC,cAAc,CAAC;KAC7C;;;;IAID,IAAI,eAAe,GAAG;QAClB,OAAO,IAAI,CAAC,cAAc,CAAC,eAAe,CAAC;KAC9C;;;;;IAKD,IAAI,cAAc,GAAG,EAAE,OAAO,IAAI,CAAC,eAAe,CAAC,EAAE;;;;;IAKrD,IAAI,cAAc,GAAG,EAAE,OAAO,IAAI,CAAC,eAAe,CAAC,EAAE;;;;;IAKrD,IAAI,SAAS,GAAG,EAAE,OAAO,IAAI,CAAC,UAAU,CAAC,EAAE;;;;;IAK3C,IAAI,yBAAyB,GAAG,EAAE,OAAO,IAAI,CAAC,0BAA0B,CAAC,EAAE;;;;;;;IAO3E,WAAW,CAAC,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE;QAC5B,KAAK,CAAC,MAAM,EAAE,OAAO,IAAI,KAAK,QAAQ,GAAG,QAAQ,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,SAAS,GAAG,IAAI,EAAE,IAAI,CAAC,CAAC;QAClG,IAAI,CAAC,IAAI,IAAI,OAAO,IAAI,KAAK,SAAS,EAAE;YACpC,IAAI,CAAC,IAAI,GAAG,QAAQ,CAAC,IAAI,CAAC;SAC7B;aACI;YACD,IAAI,CAAC,IAAI,GAAG,OAAO,IAAI,KAAK,QAAQ,GAAG,QAAQ,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,QAAQ,CAAC,IAAI,GAAG,IAAI,CAAC;SAChG;QACD,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC;QAC5B,IAAI,CAAC,eAAe,GAAG;YACnB,KAAK,EAAE,CAAC;YACR,MAAM,EAAE,CAAC;YACT,kBAAkB,GAAG,EAAE,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC,EAAE;SACrE,CAAC;QACF,IAAI,CAAC,qBAAqB,EAAE,CAAC;QAC7B,IAAI,CAAC,YAAY,EAAE,CAAC;KACvB;;;;;IAKD,YAAY,CAAC,GAAG,GAAG,EAAE,EAAE;QACnB,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC;QACpB,IAAI,GAAG,EAAE;YACL,IAAI,CAAC,eAAe,GAAG,GAAG,CAAC;YAC3B,IAAI,CAAC,eAAe,GAAG,CAAC,GAAG,IAAI,CAAC,EAAE,GAAG,IAAI,CAAC,eAAe,CAAC;YAC1D,IAAI,CAAC,UAAU,GAAG,CAAC,GAAG,IAAI,CAAC,eAAe,CAAC;YAC3C,IAAI,CAAC,0BAA0B,GAAG,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,eAAe,CAAC;SAC5E;QACD,OAAO,IAAI,CAAC;KACf;;;;IAID,qBAAqB,GAAG;QACpB,IAAI,CAAC,eAAe,CAAC,KAAK,GAAG,IAAI,CAAC,WAAW,CAAC;QAC9C,IAAI,CAAC,eAAe,CAAC,MAAM,GAAG,IAAI,CAAC,YAAY,CAAC;QAChD,IAAI,IAAI,CAAC,IAAI,KAAK,QAAQ,CAAC,IAAI;YAC3B,OAAO;QACX,MAAM,aAAa,GAAG,IAAI,CAAC,IAAI,CAAC,qBAAqB,EAAE,CAAC;QACxD,IAAI,CAAC,eAAe,CAAC,KAAK,GAAG,aAAa,CAAC,KAAK,CAAC;QACjD,IAAI,CAAC,eAAe,CAAC,MAAM,GAAG,aAAa,CAAC,MAAM,CAAC;KACtD;;;;;;;IAOD,oBAAoB,CAAC,IAAI,EAAE,UAAU,EAAE,YAAY,EAAE;QACjD,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC;QAC/B,IAAI,CAAC,cAAc,GAAG,IAAI,cAAc,CAAC,IAAI,EAAE,IAAI,CAAC,6BAA6B,CAAC,IAAI,EAAE,UAAU,CAAC,EAAE,IAAI,CAAC,IAAI,EAAE,YAAY,CAAC,CAAC;KACjI;;;;;;;IAOD,oBAAoB,CAAC,IAAI,EAAE,UAAU,EAAE;QACnC,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,IAAI,CAAC,6BAA6B,CAAC,IAAI,IAAI,IAAI,CAAC,kBAAkB,EAAE,UAAU,CAAC,CAAC,CAAC;KAC/G;IACD,6BAA6B,CAAC,IAAI,EAAE,UAAU,EAAE;QAC5C,IAAI,CAAC,qBAAqB,EAAE,CAAC;QAC7B,MAAM,YAAY,GAAG,IAAI,CAAC,eAAe,CAAC,kBAAkB,EAAE,CAAC;QAC/D,QAAQ,IAAI;YACR,KAAK,mBAAmB,CAAC,aAAa;gBAClC,OAAO;oBACH,WAAW,EAAE,YAAY;oBACzB,YAAY,EAAE,YAAY;oBAC1B,wBAAwB,EAAE,GAAG;iBAChC,CAAC;YACN,KAAK,mBAAmB,CAAC,WAAW;gBAChC,OAAO;oBACH,WAAW,EAAE,YAAY;oBACzB,YAAY,EAAE,IAAI,GAAG,YAAY;oBACjC,wBAAwB,EAAE,GAAG;iBAChC,CAAC;YACN,KAAK,mBAAmB,CAAC,IAAI;gBACzB,OAAO;oBACH,WAAW,EAAE,IAAI,CAAC,eAAe,CAAC,KAAK;oBACvC,YAAY,EAAE,IAAI,CAAC,eAAe,CAAC,MAAM;oBACzC,wBAAwB,EAAE,GAAG;iBAChC,CAAC;YACN;gBACI,OAAO,UAAU,IAAI,cAAc,CAAC,gBAAgB,CAAC;SAC5D;KACJ;CACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}